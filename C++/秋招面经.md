# 别人面经

## 讲一下哈希表内部的原理

哈希表也叫散列表，基于快速存取角度设计的，属于用空间换时间

通过一种映射关系，把给定关键字和存储位置联系起来，查找时。可以根据映射关系快速查找

构造方法：

- 直接定址法
- 出K取余法
- 数字分析法
- 折叠法

冲突：对于不同的关键字，通过哈希函数进行映射，可能会映射到同样的位置

解决方法：两种 **开放地址法** 和 **链地址法**

> 开发地址法又分为: 线性探测法，平方探测法



## 用户态和内核态的区别？

![](https://raw.githubusercontent.com/vaesong/Images/master/20230906103334.png)

**简单来说内核态就是操作系统运行线程，用户态就是线程执行用户自己的程序**

用户态：

- 不能直接使用系统资源，也不能改变 CPU 的工作状态，并且只能访问这个用户程序自己的存储空间！

内核态：

- 系统中既有操作系统的程序，也有普通用户程序。为了安全性和稳定性，操作系统的程序不能随便访问，这就是内核态。即需要执行操作系统的程序就必须转换到内核态才能执行
- 内核态可以使用计算机所有的硬件资源



从内存分区来看，所有的进程都共享一片内核空间，用以执行内核态的指令集。



**系统调用**将Linux整个体系分为用户态和内核态，为了使应用程序访问到内核的资源，如CPU、内存、I/O，内核必须提供一组通用的访问接口，这些接口就叫**系统调用**

**切换**

- **保留用户态现场（上下文、寄存器、用户栈等）**
- **复制用户态参数，用户栈切到内核栈，进入内核态**
- **额外的检查（因为内核代码对用户不信任）**
- **执行内核态代码**
- **复制内核态代码执行结果，回到用户态**
- **恢复用户态现场（上下文、寄存器、用户栈等）**



什么情况会导致用户态到内核态切换：

- 系统调用：用户态进程主动切换到内核态的方式
- 异常：当 C P U 在执行用户态的进程时，发生了一些没有预知的异常，这时当前运行进程会切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常
- 中断：当 C P U 在执行用户态的进程时，外围设备完成用户请求的操作后，会向 C P U 发出相应的中断信号，这时 C P U 会暂停执行下一条即将要执行的指令，转到与中断信号对应的处理程序去执行，也就是切换到了内核态。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等
  



## 线程池要考虑的问题

- **线程数量**：太少的线程可能无法充分利用多核CPU，而太多的线程可能导致过多的上下文切换和线程竞争，从而降低性能
- **任务队列**：用于存储待处理的任务的队列的大小和实现方式（例如，是否为先进先出）都会影响线程池的性能
- **线程创建和销毁**：线程池通常会预先创建一定数量的线程，并在没有任务时让它们处于休眠状态，而不是销毁它们
- **线程同步**：线程之间可能需要共享资源，如内存、文件等。这时，需要确保线程同步，以避免数据竞争和死锁
- **异常处理**：当线程中的任务抛出异常时，线程池应该能够恰当地处理它，例如记录错误、重启线程等



## 单例模式的优缺点

优点：

- **唯一实例**：确保某个类只有一个实例存在，可以严格控制客户怎样以及何时访问它
- **全局访问点**：提供了一个全局访问点，使得其他代码可以轻松地获取到这个唯一的实例
- **节省资源**：由于只创建一个实例，相比每次都创建新的对象，可以节省资源

缺点：

- **不易扩展**：单例类通常不能被继承
- **测试困难**：由于单例模式提供了一个全局实例，这可能使得单元测试变得困难
- **违反单一职责原则**：单例模式将对象的创建和业务逻辑放在了同一个类中，这违反了单一职责原则



## 面向过程与面向对象

**面向过程**：把事情拆分成几个步骤（相当于拆分成一个个的方法和数据），然后按照一定的顺序执行

**面向对象**：把事物抽象成类，封装好成员变量和方法，然后通过实例化的对象去执行相应的方法



## 构造函数可以是虚函数吗？

不可以，因为虚函数是需要根据对象内存的虚表指针找到虚表，然后根据虚表确定调用哪个函数。

但是不调用构造函数，没法创建对象，自然都不能加载虚表指针。

而且从目的来看，构造函数的主要是初始化新创建的对象。虚函数主要用于实现多态



## 析构函数可以抛出异常吗？

析构函数可以抛出异常，但这是一个非常不推荐的做法

如果析构函数中发生异常并且没有在析构函数内部捕获，这可能导致严重的问题。

可能会导致资源泄露，因为其他的清理代码可能不会被执行。

也会导致不可预测的行为



## 全局对象的生成过程？static成员变量？

**全局对象**是在函数外部定义的对象。它们的生命周期从程序开始时持续到程序结束

**生成和初始化过程**：

- **编译时**：编译器为全局对象分配存储空间。
- **程序启动前**：在`main()`函数执行之前，全局对象的构造函数会被调用，按照它们在源代码中的出现顺序进行初始化。
- **程序结束时**：在`main()`函数执行完毕后或调用`exit()`函数时，全局对象的析构函数会被调用，按照与构造函数相反的顺序进行销毁。



**`static`成员变量**是类的所有对象共享的成员变量

**生成和初始化过程**：

- **编译时**：编译器为`static`成员变量分配存储空间，但不进行初始化。
- **定义时**：`static`成员变量必须在类定义之外进行定义和初始化。这通常在源文件中完成，而不是在头文件中。
- **程序启动前**：与全局对象类似，`static`成员变量的初始化发生在`main()`函数执行之前。如果有多个`static`成员变量或全局对象，它们的初始化顺序可能是不确定的，除非它们在同一个编译单元中。
- **程序结束时**：`static`成员变量没有析构函数，因为它们不是对象。但如果它们是某个类的对象，那么这个类的析构函数会在程序结束时被调用。

**注意**：静态成员变量的初始化顺序在不同的编译单元之间是不确定的。这可能导致所谓的"静态初始化顺序问题"。为了避免这种问题，可以使用函数内的局部静态对象，因为它们在首次使用时进行初始化，这可以确保正确的初始化顺序。



## auto可以做返回值和函数参数吗？

`auto`可以用作函数的返回值，并且在泛型lambda中可以用作参数类型。但对于普通函数，`auto`不能直接用作参数类型



## 如何将一个普通指针与智能指针进行交换？

可以使用智能指针的成员函数和标准库提供的工具

### 1. 与`std::unique_ptr`交换：

通过 release() 释放 和 reset()重新设置

```c++
cppCopy code#include <iostream>
#include <memory>

int main() {
    int* raw_ptr = new int(10);
    std::unique_ptr<int> smart_ptr(new int(20));

    // 使用 std::unique_ptr::release() 和 std::unique_ptr::reset()
    int* temp = raw_ptr;
    raw_ptr = smart_ptr.release();
    smart_ptr.reset(temp);

    std::cout << *raw_ptr << std::endl;      // 输出：20
    std::cout << *smart_ptr << std::endl;    // 输出：10

    delete raw_ptr;
    return 0;
}
```

### 2. 与`std::shared_ptr`交换：

直接通过 swap() 交换

```C++
cppCopy code#include <iostream>
#include <memory>

int main() {
    int* raw_ptr = new int(10);
    std::shared_ptr<int> smart_ptr(new int(20));

    // 使用 std::swap()
    std::swap(raw_ptr, smart_ptr);

    std::cout << *raw_ptr << std::endl;      // 输出：20
    std::cout << *smart_ptr << std::endl;    // 输出：10

    delete raw_ptr;
    return 0;
}
```



## 模板的优缺点?

**优点：**

- 类型安全、代码重用、灵活性高



**缺点：**

- 复杂性高、兼容性问题、隔离性问题（.h 和 .cpp 不能分开）



## C++的类型转换？区别？

1. C风格的类型转换，直接前面加括号

```C++
int i = 42;
double d = (double)i;
```

2. #### `static_cast`

用于大多数常规类型转换

```C++
double pi = 3.14159;
int integer_pi = static_cast<int>(pi);
```

3. #### `dynamic_cast`

主要用于类指针或引用的上下行转换，在运行时进行检查，通常和多态一起使用

```C++
Base* b = new Derived();
Derived* d = dynamic_cast<Derived*>(b);
```

4. #### `const_cast`

用于添加或删除`const`性

```C++
const int ci = 10;
int* non_const_i = const_cast<int*>(&ci);
```

5. #### `reinterpret_cast`

进行低级别、不安全的类型转换

```C++
int i = 42;
int* p = &i;
long address = reinterpret_cast<long>(p);
```



## 平衡二叉树和红黑树的区别？

**红黑性质**：

- 每个节点要么是红色，要么是黑色。
- 根节点是黑色。
- 所有叶子节点（NIL或空节点）是黑色。
- 如果一个节点是红色，那么它的两个子节点都是黑色。
- 从任一节点到其每个叶子节点的所有路径都包含相同数量的黑色节点。



### 总结：

- **平衡性**：AVL树是严格平衡的，而红黑树提供了一种宽松的平衡，确保最长路径不超过最短路径的两倍。
- **操作性能**：AVL树提供了更快的查找操作，但插入和删除操作可能较慢。红黑树的查找性能略低于AVL树，但通常提供更快的插入和删除操作。
- **用途**：由于红黑树的插入和删除操作通常更快，所以它们在很多实际应用中，如STL中的`map`和`set`，都被广泛使用。而AVL树则更适合查找操作较多的应用。



## Hash算法与加密算法

HASH 算法是一种消息摘要算法，不是一种加密算法

哈希算法往往被设计成生成具有**相同长度**的文本，而加密算法生成的文本长度**与明文本身的长度**有关

哈希算法是不可逆的，而加密算法是可逆的



## MySQL如何优化慢查询？



## SQL注入？



## Redis 的核心数据类型？

- string 字符串类型
- list 列表类型
- set 集合类型
- sorted set 有序集合类型
- hash 类型
- bitmap 位图类型
- geo 地理位置类型
- HyperLogLog 基数统计类型



## 了解线段树嘛？

