# C++

## 语法

### 定义和声明的区别？

**对于变量**：声明只是告诉编译器，有某个类型的变量将要被使用，但是并不会为其分配内存。而定义就会直接分配内存

**对于函数**：声明一般都在头文件里，告诉编译器存在这个函数。而定义一般都在源文件里，是函数的具体实现

- 声明仅仅只是告诉编译器某个类型的变量以及函数存在，不会分配具体的内存，定义会在定义的地方分配存储空间
- 相同的变量可以多处声明，但是只能在一处定义



### 初始化和赋值的区别

- 对于简单类型来说，没什么区别
- 对于类和复杂类型来说，初始化会调用拷贝构造函数，赋值会调用重载的赋值运算符



### 全局变量和局部变量

- 生命周期不同，全局变量随主程序的创建而创建，销毁而销毁，局部变量随某个函数或者循环创建以及销毁
- 位置不同，全局变量分配在全局数据区，各个程序的各个部分都能用到。而局部变量分配在 堆栈区，只能局部使用



### 形参和实参的区别

- 时间上来看，形参只有在函数别调用的时候，才会在堆栈区分配内存，并且只能在函数内部使用，函数结束就会销毁内存。而实参在函数调用的时候，必须有确定的值。
- 从数量及类型上看，实参和应参必须是一一对应的，包括数量，类型都应该严格一致
- 从数据流流向来看，只能把实参的值传递给形参，而不能把形参的值传递给实参，因此，函数调用的时候，形参的值会发生改变而实参不会。而如果是引用或者指针类型，那么形参改变而实参也会跟着变化



### 说说静态变量，全局变量，局部变量？







## 面向对象

## 智能指针

## 内存

### 谈谈C++的内存对齐？

[博客（地址按字节寻址，移动一个字节加一）](https://blog.csdn.net/weixin_48896613/article/details/127371045)

- 内存对齐：在 C 语言中，结构体是一种复合数据类型，它的构成元素可以是基本数据类型（int、long、float等），也可以是复合数据类型（数组、结构体等）的数据单元。为了让 CPU 能够对变量进行快速访问，变量的起始地址应该具有某种特性，即 "对齐"。例如 4 字节的 int 型，它的起始地址应该位于 4 字节的边界上，也就是能被 4 整除。这样就称之为自然对齐，于是 CPU 可以一次取出数据
- C++ 内存对齐：用于三种数据类型：struct / class / union，对齐原则有四个
  1. 数据成员对齐规则： struct 或者 union 的数据成员，第一个数据成员放在 offset 为 0 的地方，以后每个数据成员存储的起始位置都要从该成员大小或者成员的子成员大小的整数倍开始
  2. struct 作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部 “最宽基本类型成员” 的整数倍地址开始存储（struct A 里面有成员 struct B，B里的成员有 char，int， double等元素，那 B 应该从 8 的整数倍开始存储）
  3. 收尾工作：结构体的大小，也就是 sizeof 的结果，必须是其内部最大成员的 “最宽基本类型成员” 的整数倍。不足的要补齐
  4. sizeof(union) 以结构里面 size 最大的元素为 union 的 size，因为在某一时刻，union 只有一个成员真正的存储在该地址



### 为什么C++没有垃圾回收机制？

垃圾收集器：是一种动态存储分配器，它自动释放程序不再需要的已分配的块，这些块也被成为垃圾。在程序员看来，垃圾就是不再被引用的对象，自动回收垃圾的过程则称为垃圾收集。

- 首先，实现一个垃圾回收器会带来额外的空间和事件开销，需要开辟一定的空间保存指针的引用计数和对他们进行标记 mark，然后需要单独开辟一个线程在空闲的时候进行 free 操作
- 垃圾回收会使得 C++ 不适合进行很多底层操作



### 什么是内存泄漏？

内存泄露：简单的说就是申请了一块内存地址，但是用完之后没有释放掉

- new 和 malloc 申请资源使用后，没有使用 delete 和 free 释放
- 子类继承父类时，父类析构函数不是虚函数
- Windows 句柄资源使用后没有释放

后果：只发生一次小的内存泄漏可能不被注意，但泄露大量的内存程序将会出现各种症状；性能下降到内存逐渐用完，导致另一个程序失败

如何避免：

- 使用内存分配的函数，一旦使用完毕，要记得使用其对应的函数释放掉。有 new 就有 delete，有 malloc 就有 free，对象数组一定要用 delete []
- 一定要把基类的析构函数声明为 虚函数
- 使用智能指针



### C++ 的内存分区？

1. 栈区：存放函数的参数值和局部变量的值，由编译器自动分配和释放
2. 堆区：由程序员申请后使用，需要手动释放否则会造成内存泄漏。如果程序员没有手动释放，那么程序结束可能由操作系统回收
3. 全局/静态 存储区：存放全局变量和静态变量，初始化的全局变量和静态变量放在一块，未初始化的放在另一块
4. 常量区：存放常量字符串、常量变量等。程序启动时自动分配，程序结束时系统释放。
5. 程序代码区：存放程序的二进制代码，内存由系统管理



### 堆和栈的区别？

|                |             堆                                               |                    栈                                          |
| ---------------- | :----------------------------------------------------------- | :----------------------------------------------------------: |
| **管理方式**     | 堆中资源由程序员控制（容易产生memory leak）                  | 栈资源由编译器自动管理，无需手工控制                         |
| **内存管理机制** | 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中） | 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了） |
| **空间大小**     | 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。 堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大 | 栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。 栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置） |
| **碎片问题**     | 对于堆，频繁的new/delete会造成大量碎片，使程序效率降低       | 对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别） |
| **生长方向**     | 堆向上，向高地址方向增长。                                   | 栈向下，向低地址方向增长。                                   |
| **分配方式**     | 堆都是动态分配（没有静态分配的堆）                           | 栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。 |
| **分配效率**     | 堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。 | 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。 |



### segment fault是什么错误？

通常是以下几个原因：

- 内存访问越界
- 多线程程序使用了线程不安全的函数
- 非法指针
- 堆栈溢出



### new/delete、malloc/free

- new/delete 是 C++ 操作符关键字，需要编译器支持， malloc 是 C/C++  标准库函数，需要头文件支持
- 使用 new 申请内存时，不用指定内存块的大小， 使用 malloc 申请内存时，需要显式的指出需要分配的内存大小
- new 分配失败时，会抛出 bac_alloc 异常，而 malloc 失败时会返回 NULL
- new 分配成功时会返回对象类型的指针，但是 malloc 成功时会返回 void，需要强转成 需要的类型
- new/delete 会调用对象的构造函数 和 析构函数，而 malloc/free 不会调用



### 被free回收的内存会立即返还给操作系统吗？

不是的，被 free 的内存会使用双链表保存起来，当用户下一次申请内存的时候，会尝试在链表中寻找合适的内存，这样就避免了频繁的系统调用



### C++中有几种 new

plain new，nothrow new, placement new



### delete p, delete [] p 的区别？

- delete 只会调用一次析构函数
- delete [] p 会调用数组中每个元素的析构函数
- delete [] 的时候，按数组中元素的逆序销毁



### 内存池？

内存池（Memory Pool） 是一种**内存分配**方式。通常我们习惯直接使用new、malloc 等申请内存，这样做的缺点在于：由于所申请内存块的大小不定，当频繁使用时会造成大量的内存碎片并进而降低性能。内存池则是在真正使用内存之前，先申请分配一定数量的、大小相等(一般情况下)的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块， 若内存块不够再继续申请新的内存。这样做的一个显著优点是尽量避免了内存碎片，使得内存分配效率得到提升。



### C++中类的数据成员和成员函数内存分布情况？

- 类的大小：
  - **非静态成员**的数据类型大小之和
  - 边缘对齐优化加入 padding：内存对齐另外分配的空间大小，类内的数据也是需要进行内存对齐操作的
  - 有虚函数的话，会在类对象插入vptr指针，加上指针大小
- 静态成员不占据类的空间，成员函数也不占据类的空间大小
- 当该类是某类的派生类，那么派生类继承的基类部分的数据成员也会存在在派生类中的空间中，也会对派生类进行扩展
- 一个类对象的地址就是类所包含的这一片内存空间的首地址，这个首地址也就对应具体某一个成员变量的地址
- 对象的大小和对象中数据成员的大小是一致的，成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。
- 静态成员函数的存放问题：静态成员函数与一般成员函数的唯一区别就是没有this指针，因此不能访问非静态数据成员。所有函数都存放在代码区，静态函数也不例外。所有有人一看到 static 这个单词就主观的认为是存放在全局数据区，那是不对的。



### 深拷贝和浅拷贝？

浅拷贝：浅拷贝只是拷贝一个指针，并没有开辟新的内存空间，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出错

在计算机中开辟了一块新的内存地址用于存放复制的对象。

深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。



### 对象复用和零拷贝？

**对象复用**的本质是一种设计模式：Flyweight享元模式

通过把对象存储到“对象池”中实现对象的重复利用，可以避免多次创建重复对象的开销，节省系统资源

**零拷贝**：是一种避免 CPU 把数据从一块存储拷贝到另外一块存储的技术，可以减少数据拷贝和共享总线操作的次数

在 C++ 中，vector 的成员函数 **emplace_back** 很好的体现了零拷贝技术，跟 **push_back** 一样可以把元素车入到容器的尾部，区别在于：**使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造**，效率更高。



### 类如何实现只能静态分配？和只能动态分配？

建立类的对象有两种方式：

① 静态建立：静态建立一个类对象，就是由编译器为对象在栈空间中分配内存

② 动态建立：A *p = new A(); 动态建立一个类对象，就是使用new运算符为对象在堆空间中分配内存。这个过程分为两步，第一步执行operator new()函数，在堆中搜索一块内存并进行分配；第二步调用类构造函数构造对象

**只能动态分配**

类对象只能通过new运算符建立在堆空间中，不能静态分配，即不能直接调用类的构造函数

1.  private 构造函数（不可行），没法调用 构造函数
2. private 析构函数（无法实现继承），如果类的析构函数在类外部无法访问，则编译器拒绝在栈空间上为类对象分配内存。因此，可以将析构函数设为private，这样就无法在栈上建立类对象了。但是当作为基类让子类继承的时候，需要把析构函数设置为 virtual 函数，然后子类重写虚析构函数，但如果是 private 的话，子类是无法访问的。
3. 构造、析构函数设为 protected。将析构函数设为protected，类外无法访问protected成员，但是子类可以访问。

**只能静态分配**

只有使用 new 运算法，才会在堆上动态创建对象，于是，限制 new 运算符的使用即可。可以把 new 运算符设置为 私有



### 函数调用的过程

1. 第一个进栈的是（主函数中的） 调用处的下一条指令（即函数调用语句的下一条可执行语句） 的地址；

2. 然后是函数的各个参数，而在大多数C/C++编译器中，在函数调用的过程中，函数的参数是 由右向左入栈的；

3. 然后是函数内部的 局部变量（注意static变量是不入栈的）；

在函数调用结束（函数运行结束）后

1. 局部变量最先出栈

2. 然后是参数

3. 最后栈顶指针指向最开始存的指令地址，程序由该点继续运行。



### 谈谈智能指针?

智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源





## 容器

## 多线程

## 模板

## 编译和链接

### C++从代码到可执行二进制程序的流程

C++从源文件到可执行文件一共有四个步骤，**预编译、编译、汇编、链接**

**预编译：**将头文件、宏进行展开

1. 删除所有的 #define，并展开所有的宏定义
2. 删除所有的条件预编译指令，#if，#ifdef
3. 处理所有的 include 预编译指令，把被包含的文件插入到预编译指令的位置
4. 过滤所有的注释
5. 添加行号和文件名标识

**编译：**把预编译生成的 .i 或者 .ii 文件，进行一系列的 **词法分析、语法分析、语义分析以及优化** 后，生成相应的汇编代码文件

1. 词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分 割成一系列的记号。
2. 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的 语法树是一种以表达式为节点的树。
3. 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进 行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定 的语义。
4. 优化：源代码级别的一个优化过程。
5. 目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言 表示。
6. 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移 来替代乘法运算、删除多余的指令等。 

**汇编：**把编译生成的汇编代码转换成机器可以执行的指令。汇编之后，产生目标文件 xxx.o(Windows 下)、xxx.obj(Linux下)



**链接：**把不同源文件产生的目标文件进行链接，从而形成一个可执行程序。链接分为静态链接和动态链接

静态链接：在链接的时候就把需要调用的函数链接到了可执行文件中。生成的静态链接库，Windows下为 .lib，Linux 下为 .a

- 优点是，运行速度快，不依赖动态链接库
- 缺点是，空间浪费，更新代码困难

动态链接：在链接的时候，没有把需要的函数链接到可执行文件，而是在执行的过程中，再根据可执行文件中函数的重定位信息去找要链接的函数。生成的动态链接库在 Windows 下是 .dll，在 Linux 下是 .so

- 优点是，更新方便，只需要替换原来的目标文件。动态编译，加快了编译速度，节省了系统资源
- 缺点是，性能损耗，每次执行都要链接。如果计算机上没有安装相应的动态库，那可执行文件就不能运行



### 什么是 GCC，工作原理是什么？？

gcc 全称是 GNU **Compiler Collection** ，它是能够编译多种语言的编译器





### 写个函数在 main 函数前面执行？

全局变量的构造函数会在 main 函数之前执行

```C++
class App{
public:
    App(){
        cout << "First" << endl;
    }
};

App a;

int main(){
    cout << "Second" << endl;
    return 0;
}
```



# 操作系统



# 计算机网络



# 数据库



# Webserver

### 为什么要做这个项目

该项目是





### 什么是阻塞和非阻塞以及同步和异步？

对于一次 I/O 来说，有数据就绪阶段以及数据读写两个阶段。

对于数据就绪阶段，根据系统 I/O 操作的就绪状态来区分阻塞和非阻塞。

- 阻塞 I/O是指，当用户线程发起 I/O 请求时，如果数据还未准备就绪，就会**阻塞**当前线程，让出 CPU
- 非阻塞 I/O 是指，当用户线程发起 I/O 请求时，如果数据还未准备就绪，也**不会阻塞**当前线程，可以继续执行后续的任务

对于数据读写阶段，根据系统 I/O 响应方式不同来区分同步和异步

- 同步 I/O 是指，当用户线程发起 I/O 请求时，数据已经准备好了，需要把内核空间的数据拷贝到用户空间，此时用户线程会**等待拷贝完成**
- 异步 I/O 是指，当用户线程发起 I/O 请求时，数据已经准备好了，需要把内核空间的数据拷贝到用户空间，此时用户线程**不会等待拷贝完成**

### webserver两种高效的事件处理模式？

服务器通常需要处理三类事件：I/O 事件，信号以及定时事件，两种高效的事件处理模式分别是 Reactor 和 Proactor。

**Reactor模式**，要求主线程只负责监听文件描述符上是否有事件发生，如果有的话，就把该事件通知给工作线程，将 socket 可读可写事件放入到请求队列中，交给工作线程处理。除此之外，主线程不做其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。

使用同步 I/O 实现 Reactor 模式的工作流程为：

1. 主线程向 epoll_wait 内核事件表内注册 socket 上的读就绪事件
2. 然后调用 epoll_wait 等待 socket 上有数据可读
3. 当 socket 上有数据可读的时候， epoll_wait 通知主线程，主线程把 socket 可读事件放入到请求队列
4. 然后唤醒一个工作线程，从 socket 上读取数据，处理客户请求，再往 epoll 内核事件表中注册该 socket 上的写就绪事件
5. 主线程调用 epoll_wait 等待 socket 可写
6. 当 socket 可写的时候， epoll_wait 通知主线程，主线程把 socket 可写事件放入到请求队列
7. 唤醒请求队列上的工作线程，向 socket 上写入服务器处理客户请求的结果

![](https://cdn.jsdelivr.net/gh/vaesong/Images//20230218204203.png)



**Proactor 模式**，把所有的 I/O 操作都交给主线程和内核去处理（进行读写操作），工作线程仅仅负责业务逻辑。

使用异步 I/O 实现 Proactor 模式的工作流程：

1. 主线程调用 aio_read 函数向内核注册 socket 上的读完成时间，并告诉内核用户读缓冲区的位置，以及读操作完成时通知应用程序的方式
2. 主线程继续处理其他逻辑
3. 当 socket 上的数据被读到用户缓冲区后，内核向应用程序发送一个信号，通知应用程序数据已经可用
4. 应用程序预先定义的信号处理函数选择一个工作线程处理客户请求，工作线程完成后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时通知应用程序的方式
5. 主线程继续处理其他逻辑
6. 当用户缓冲区的数据被写入到 socket 后，内核向应用程序发送信号，通知应用程序数据已经发送完啦
7. 应用程序预先定义的信号处理函数选择一个工作线程进行善后处理，比如决定是否关闭 socket 

![](https://cdn.jsdelivr.net/gh/vaesong/Images//20230218205644.png)



**二者区别：**在于 Reactor 模式的工作线程不仅负责业务逻辑处理，还需要完成数据的读写操作。而 Proactor 模式的工作线程仅负责业务逻辑处理。

**模拟 Proactor 模式：**用主线程来完成数据的读写过程，这样对于工作线程来说，就直接获得了数据读写的结果，只需要进行逻辑处理就行

使用同步 I/O 模型模拟的 Proactor 模式的工作流程如下

1. 主线程向 epoll 内核事件表注册 socket 上的读事件
2. 主线程调用 epoll_wait 等待 socket 上有数据可读
3. 当 socket 上有数据可读时，epoll_wait 通知主线程，主线程读取数据，然后封装成一个请求对象，插入到请求队列中
4. 唤醒一个工作线程，获得请求对象处理客户请求，然后向 epoll 内核事件表中注册 socket 上的写就绪事件
5. 主线程调用 epoll_wait 等待 socket 可写
6. 当 socket 可写时，epoll_wait 通知主线程，主线程向 socket 上写入服务器处理客户请求的结果

![](https://cdn.jsdelivr.net/gh/vaesong/Images//20230218210647.png)





### 信号

三种常见的信号：SIGHUP，SIGPIPE，SIGURG

SIGHUP:

- SIGHUP 信号在**用户终端连接(正常或非正常)结束**时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联. 系统对SIGHUP信号的**默认处理是终止收到该信号的进程**。

SIGPIPE:

- 当往一个写端关闭的管道或socket连接中连续写入数据时会引发SIGPIPE信号,引发SIGPIPE信号的写操作将设置errno为EPIPE。在TCP通信中，当通信的双方中的一方close一个连接时，若另一方接着发数据，根据TCP协议的规定，会收到一个RST响应报文，若再往这个服务器发送数据时，系统会发出一个SIGPIPE信号给进程，告诉进程这个连接已经断开了，不能再写入数据。

SIGURG:

- 内核通知应用程序带外数据到达的方式有两种：一种就是利用ＩＯ复用技术的系统调用（如select）在接受到带外数据时将返回，并向应用程序报告socket上的异常事件。 
- 另一种方法就是使用SIGURG信号。



### 说一下 ET，LT，one_shot

首先，ET 和 LT 可以理解为是事件层面的，当有 socket 的数据到达的时候，会产生 EPOLLIN 事件

如果是 ET（边缘触发），那么该事件仅仅通知一次，不管到达的数据是否读完，下一次都不会再产生 EPOLLIN 事件，因此需要一次读完

如果是 LT（电平触发），那么该事件会通知多次，只要数据没有读完，那么就会一直产生 EPOLLIN 事件通知 socket 读取数据

而 one_shot，是线程层面的，当已经读取完某个 socket 的 EPOLLIN 事件的数据之后，会插入到请求队列中。这时候会从线程池中选择一个线程进行数据的解析处理（例如解析 HTTP 报文，生成 HTTP 响应报文等）。如果这个时候该 socket 上再次有 EPOLLIN 事件，主线程读取完数据之后插入到请求队列，这时会选择另外一个线程处理该请求，那么就会出现两个线程同时处理一个 socket 的请求这种情况。我们的设想肯定是一个 socket 的数据在某一时刻只由一个 工作线程处理，于是使用 one_shot。如果该 socket 注册 one_shot 事件，它规定操作系统最多触发其上注册的一个可读、可写或者异常事件，当触发了 EPOLLIN 事件之后，那么即使有后续的数据过来，也不会产生 EPOLLIN 事件，只有前面的线程处理完数据之后，才会重新注册 one_shot 事件。从而保证每个 socket 的数据不会**同时**被两个线程处理。

**一个socket在不用时期可以由不同工作线程处理，但同一时刻只有一个线程为之服务，保证了连接的完整性，避免了很多可能的竟态条件。**



### 说一下 select、poll、epoll 的区别是什么

首先，它们是 linux 下的三种不同的 I/O 复用的方式

- select 使用线性表描述文件描述符的集合，文件描述符有上限，poll 使用链表来描述，而 epoll 底层通过红黑树来描述，并且维护一个 ready list，把事件表中已经就绪的事件添加到这里，在使用 epoll_wait 调用时，观察这个 list 中有没有数据
- 对于 select 和 poll 来说，所有的文件描述符都是在用户态被加入其文件描述符集合，每次调用都需要把整个集合拷贝到内核态；而 epoll 是把整个文件描述符集合维护在内核态，每次添加文件描述符都需要执行系统调用
- select 和 poll 的最大开销来自内核判断是否有文件描述符就绪这个过程：每次执行 select 或 poll 调用，就会遍历整个文件描述符集合来判断是否有文件描述符就绪。而 epoll 不用，当有活动产生时，会自动触发 epoll 回调函数通知 epoll 文件描述符，然后内核把这些就绪的文件描述符放到 ready list 中等待 epoll_wait 调用
- select 和 poll 只能在 LT 模式下工作，而 epoll 同时支持 LT 和 ET 模式
- 当检测的文件描述符较少时，且每个文件描述符都比较活跃的情况下， select 和 poll 的效率较高。当监听的文件描述符较多且不太活跃的情况下，使用 epoll 较好





# 设计模式

