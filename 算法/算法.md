# 算法

# 数组

## 二分法的思想

整体思路：看见排序的数组（或者自行排序），可以考虑到使用二分法

### [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

思路：

在有序数组中寻找指定元素，显然使用二分法。主要是在于区间的选取方式，是左闭右开 还是 左闭右闭。然后使用while循环进行查找

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n=nums.size();
        return BinaryFind(nums,0,n-1,target);
    }

    //二分查找
    int BinaryFind(vector<int>& nums,int left,int right,int target)
    {
        //如果没有找到，那么返回-1
        if(left > right)
            return -1;
        else 
        {
            int mid = (left + right)/2;
            if(nums[mid] == target)
                return mid;
            else if(nums[mid] > target)
                return BinaryFind(nums,left,mid-1,target);
            else
                return BinaryFind(nums,mid+1,right,target);            
        }

    }
};
```



## 双指针

使用两个指针进行操作，包括快慢指针，头尾指针等

### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

思路：

使用双指针（快慢指针）的思想，慢指针的值等于快指针的值，但是只有当快指针不是目标元素时才进行赋值，否则继续向后移动

```C++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowindex = 0;
        int n = nums.size();
        //快指针不断遍历，当是目标元素时，不进行赋值，只有不是目标元素时，才进行赋值
        for(int fastindex = 0;fastindex < n;fastindex++)
        {
            if(nums[fastindex] != val)
                nums[slowindex++] = nums[fastindex];
        }
        return slowindex;
    }
};
```



### [977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

思路：

双指针，因为是非递减顺序，所以前面可以是负数，并且可以两个连续的数相同。 但是平方过后，负数的平方可能比较大。但是平方过后的最大值一定在原数组的最左或者最右边。所以两边都有指针，取最大的放到新数组的最后面。

```C++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> res(nums.size(), 0);
        int left = 0;
        int right = nums.size() - 1;
        int cur = nums.size() - 1;
        while(left <= right){
            long int letf_square = nums[left] * nums[left];
            long int right_square = nums[right] * nums[right];
            if(letf_square > right_square){
                res[cur--] = letf_square;
                left++;
            }
            else{
                res[cur--] = right_square;
                right--;
            }         
        }
        return res;
    }
};
```
### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

思路：

滑动窗口法 。让一个“窗口”一直向前移动，保证里面的序列和是符合条件的，小的话快指针就向后移动，大的话慢指针向后移动。

```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res = INT32_MAX;
        int sublength = 0;
        //定义慢指针
        int slow = 0;
        //定义sum 表示序列的和
        int sum = 0;
        for(int fast = 0;fast < nums.size();++fast)
        {
            //将当前位置的数加上去
            sum += nums[fast];

            //如果当前的和过大，那么就移动左边的窗口
            while(sum >= target)
            {
                sublength = (fast - slow +1);
                res = res < sublength ? res : sublength;
                sum -= nums[slow++];
            }
        }
        //如果res没有被赋值的话，那么就返回0
        return res == INT32_MAX ? 0 : res;
    }
};
```

## 模拟题

根据实际情况去模拟每一个步骤的操作

### [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

思路：

首先将上下左右四条边的赋值看成一轮循环，然后在每一轮循环的时候赋值。

定义圈数和每轮循环的起始位置，以及偏移量等，偏移量初始化为1 是因为在每次循环中，都不会把最后一个位置赋值，而是留给下一个循环去赋值

```C++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0));
        //定义当前的值
        int cur_val = 1;
        //定义圈数
        int loop = n/2;
        //定义起始位置
        int start_i = 0;
        int start_j = 0;

        //定义偏移量, 初始化为1 是因为最后一个位置留给下一次循环去赋值
        int offset = 1;

        while(loop--){
            int i = start_i;
            int j = start_j;
            //从左到右
            for(j = start_j; j < n - offset; ++j){
                res[i][j] = cur_val;
                cur_val++;
            }

            //从上到下
            for(i = start_i; i < n - offset; ++i){
                res[i][j] = cur_val;
                cur_val++;
            }

            //从右到左
            for(; j > start_j; --j){
                res[i][j] = cur_val;
                cur_val++;
            }

            //从下到上
            for(; i > start_i; --i){
                res[i][j] = cur_val;
                cur_val++;
            }
            start_i++;
            start_j++;
            offset += 1;
        }

        if(n%2 != 0){
            res[n/2][n/2] = n*n;
        }
        return res;
    }
};
```

# 链表

链表的操作多是使用双指针，即一个 pre 和一个 cur

### [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

思路：

设置虚拟节点可以把头结点当做正常节点一样对待，一样处理

整体思路就是，双指针，前驱结点pre，当前节点 cur，当碰到 cur 的值是要删除的值，就跳过

```C++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* pre = dummyHead;
        ListNode* cur = head;
        while(cur != NULL){
            if(cur->val == val){
                cur = cur->next;
                pre->next = cur;
                continue;
            }
             
            pre = cur;
            cur = cur->next;
        }
        return dummyHead->next;
    }
};
```

### [707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/)

思路：

注意，不要随意使用链表的长度！！！！而且插入时，需要注意到前后的连接！！



### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

思路：

原地反转，使用双指针，保存后一个指针，然后把当前指针指向前面

```C++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head == NULL)
            return NULL;
        ListNode* cur = head;
        ListNode* pre = NULL;
        while(cur->next != NULL){
            ListNode* temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
        }
        cur->next = pre;
        return cur;
    }
};
/*********************				双指针递归（函数）法				*****************************/
class Solution {
public:

    //就是写一个函数进行两个节点之间的反转，然后进行递归
    ListNode* reverse(ListNode* pre,ListNode* cur){
        if(cur == NULL) 
            return pre;
        ListNode* temp = cur->next;
        cur->next = pre;
        return reverse(cur,temp);
    }
    
    ListNode* reverseList(ListNode* head) {
        return reverse(NULL,head);
    }
};
```

### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

思路：

刚开始有点懵，实际上也就是双指针

需要虚拟节点方便操作，pre指向交换两节点的前驱结点，cur指向交换的第一个节点

需要判断第二个节点是不是空，在判断next的时候，由于跳了两个，需要判断前一个是否为空

交换第一个节点和第二个节点，再向前移动两个位置

```C++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head == NULL)
            return NULL;
        //虚拟节点方便操作
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        //定义双指针，pre指向交换的两节点的前面一个节点
        ListNode* pre = dummyHead;
        ListNode* cur = head;
        //判断这个节点不是空之后，需要判断第二个交换的节点是否是空，后面就无所谓了
        while(cur != NULL && cur->next != NULL){
            //temp 代表第二个交换的节点
            ListNode* temp = cur->next;
            //交换第一个和第二个节点
            cur->next = temp->next;
            temp->next = cur;
            pre->next = temp;
            //向后移动两个位置
            cur = temp->next->next;
            pre = pre->next->next;
        }
        return dummyHead->next;
    }
};
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

思路：

倒数第几个节点的问题可以转化为，两个指针的距离是 n，而快指针就是尾结点，慢指针就是倒数第 n 个节点

先让快指针走 n 步，再让慢指针走（注意之间的距离与 n 的关系）

```C++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(head == NULL)
            return NULL;
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;

        ListNode* slow = dummyHead;
        ListNode* fast = dummyHead;
        //快指针先走
        while(fast->next != NULL && n--){
            fast = fast->next;
        }
        //两个指针同时走，快的到达终点后，删除慢指针的后一个指针
        while(fast->next != NULL){
            slow = slow->next;
            fast = fast->next;
        }

        //删除节点
        ListNode* temp = slow->next;
        slow->next = temp->next;
        delete(temp);
        
        return dummyHead->next;
    }
};
```

### [面试题 02.07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

思路：

整体思路就是相交在同一个节点，那么两个指针的值是相同的（都是该节点的地址），于是需要末尾对齐

首先求出各自的长度，然后让长链表指针后移，距离是长度之间的差值，让它们末尾对齐

然后同时移动，找到两个指针值相同的位置

问：如果是求中间相交的节点呢？

```C++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        //各遍历一遍找到它们之间长度的差值
        int num_A = 0;
        int num_B = 0;

        //获得链表A的长度
        ListNode* cur = headA;
        while(cur != NULL){
            num_A++;
            cur = cur->next;
        }
        //获得链表B的长度
        cur = headB;
        while(cur != NULL){
            num_B++;
            cur = cur->next;
        }

        ListNode* cur_A = headA;
        ListNode* cur_B = headB;
        //获得长度的差值，把它们尾部对齐
        int n = abs(num_A-num_B);
        if(num_A > num_B){
            while(n--){
                cur_A = cur_A->next;
            }
        }
        else{
            while(n--){
                cur_B = cur_B->next;
            }
        }

        //两个指针同时移动
        while(cur_A != NULL && cur_B != NULL){
            if(cur_A == cur_B)
                return cur_A;

            cur_A = cur_A->next;
            cur_B = cur_B->next;
        }
        return NULL;
    }
};
```

### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

思路：

首先快慢指针判断是否有环是显而易见的，但是怎么判断换的入口在哪里呢？？？

 经过数学推论，可以得出一个结论：**当快慢指针相遇时，在头结点和相遇节点同时出发两个指针，每次走一步，那么相遇时就是环的入口**

```C++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        //快慢指针，先确定是否有环
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast != NULL && fast->next != NULL){
            slow = slow->next;
            fast = fast->next->next;

            //如果两者相遇，说明有环
            if(slow == fast){
                //从头结点和相遇节点处开始，每次走一步，相遇时即为环的入口
                ListNode* index1 = head;
                ListNode* index2 = fast;
                while(index1 != index2){
                    index1 = index1->next;
                    index2 = index2->next;
                }
                return index1;
            }
        }
        return NULL;
    }
};
```





# 哈希表

哈希表擅长处理查找，或出现次数等问题

### [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

思路：

就是利用哈希表的思想，把每个字母映射成数字，遍历第一个字符串时出现一次加一次，遍历第二个字符串的时候，出现一次减一次。最后判断是不是全是 0。当然可以使用数组进行映射

```C++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};

        //遍历第一个字符串
        for(int i = 0;i<s.size();++i){
            record[s[i]-'a']++;
        }

        //遍历第二个字符串
        for(int j = 0;j<t.size();++j){
            record[t[j]-'a']--;
        }

        //检查
        for(int i = 0;i<26;++i){
            if(record[i] != 0)
                return false;
        }

        return true;
    }
};
```

### [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

思路：

就是把 nums1 的数放到 unorder_set 里面，再遍历 nums2，如果能在 set 里面找到，那就放到结果中，并从set里面擦除

```C++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> un_set;
        vector<int> res;
        for(int i = 0; i < nums1.size(); ++i)
            un_set.insert(nums1[i]);

        for(int j = 0; j < nums2.size(); ++j){
            auto it = un_set.find(nums2[j]);
            if(it != un_set.end()){
                res.push_back(nums2[j]);
                un_set.erase(nums2[j]);
            }
        }
        return res;
    }
};
```

### [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

思路：

首先给一个数，需要计算各个位置上数的平方和，那么可以写一个函数。并不需要判断这个数是多少位，只需要每次取末尾数的平方加到 sum 上，然后 n 去掉末尾（n /= 10）

无限循环意味着，曾经的和可能会再次出现，这就说明不可能是快乐数

```C++
class Solution {
public:
    //计算和
    long int getsum(int n){
        long int sum = 0;
        while(n){
            sum += (n%10) * (n%10);
            n /= 10;
        }
        return sum;
    }

    bool isHappy(int n) {
        unordered_set<long int> res;
        while(getsum(n) != 1){
            if(res.find(getsum(n)) != res.end()){
                return false;
            }
            else {
                res.insert(getsum(n));
                n = getsum(n);
            }
        }
        return true;

    }
};
```

## 几数之和

此类题目通常从 两数之和开始，到三数之和，四数之和

对于几数之和来说，如果求的是元素值而不是下标，那么就可以使用双指针的方法在原本的复杂度上降低一个数量级。比如三数之和的O（n3）变成O（n2）

**双指针：** 需要先排序（为了去重和双指针的移动），留下两个指针左右移动，剩下的使用for循环当做固定的。判断这些和与目标值的关系来移动左右指针，注意在相等放入结果容器之后，需要移动两边的指针，同时注意去重

不使用哈希表的原因就是去重比较麻烦

### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

思路：

map可以保存 值和下标，无序容器更加快，省去了排序的时间

从头开始遍历，看另外一个数是不是在 map 里，如果找到，则返回。否则将这个数和下标插入到 map 里。

```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> un_map;
        for(int i = 0; i < nums.size(); ++i){
            if(un_map.find(target-nums[i]) != un_map.end()){
                return vector<int>{un_map.find(target-nums[i])->second, i};
            }
            else
                un_map.insert({nums[i], i});
        }
        return vector<int>{0, 0};
    }
};
```

### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

思路：

**哈希法**：两重循环判断，固定第一个数的位置，内循环的时候，如果能找到剩下的值，就放到结果里，并且把 set 容器里的 b 删除，这样相当于对 c 去重，找不到就放入 set 中当 b

**双指针法**：首先进行排序，以便移动指针。然后固定一个 i 表示以 i 开头的三元组。left = i + 1，right 在末尾的位置，当三个位置的和相加**大于 0** 时，将 right 向左移动，**小于0**时，left向右移动。当**等于0**时，放到结果里，这时候，需要两边需要移动，如果只移动一个，另一个不不动，那么结果仍然会重复。在移动的过程中注意重复。

注意：需要判断 i 是否会重复，i > 0 && nums[i] != nums[i-1]

思考：两数之和为什么不用双指针？因为返回的是下标，不能排序！！！



```C++
/****************************************    哈希表（要去重）		***************************************/
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;

        for(int i = 0; i < nums.size(); ++i){
            // a 去重
            if(i > 0 && nums[i] == nums[i-1])
                continue;
            unordered_set<int> un_set;
            for(int j = i+1; j < nums.size(); ++j){
                // 去重 b，这个地方不明白
                if(j > i+2 && nums[j] == nums[j-1] && nums[j-1] == nums[j-2])
                    continue;
                auto it = un_set.find(0-nums[i]-nums[j]);
                if(it != un_set.end()){
                    res.push_back({nums[i], *it, nums[j]});
                    // 去重 c,因为删除容器里的b之后，不会再出现 nums[j] = c 了
                    un_set.erase(0-nums[i]-nums[j]);
                }     
                else
                    un_set.insert(nums[j]);
            }
        }
        return res;
    }
};
/****************************************    三指针	***************************************/
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        for(int i = 0; i < nums.size(); ++i){
            if(i > 0 && nums[i] == nums[i-1])
                continue;

            int left = i + 1; 
            int right = nums.size()-1;
            
            while(left < right){
                int sum = nums[i] + nums[left] + nums[right];
                if(sum == 0){
                    res.push_back({nums[i], nums[left], nums[right]});
                    //两边同时收缩，因为只收缩一边，另外一个值仍然是重复值
                    //收缩的时候，需要去重
                    while(left < right && nums[left+1] == nums[left])
                        left++;
                    while(left < right && nums[right] == nums[right-1])
                        right--;

                    left++;
                    right--;
                }          
                else if(sum < 0)
                    left++;
                else
                    right--;
            }
        }
        return res;
    }
};
```

### [18. 四数之和](https://leetcode-cn.com/problems/4sum/)

思路：

**双指针法**：类似三数之和，本题需要的是四个指针，那四个指针如何移动判断呢？

固定两个指针 i ，j 剩下两个进行大小的移动，即需要两重循环

仍然是需要判定重复，需要注意的是，j 指针的重复怎么判断，简单的让 nums[j] == nums[j-1]并不行，如果 j == i 的时候，就会误判，所以需要让 j > i +1 && nums[j] == nums[j-1] 的时候这个时候才是 j 的重复判定

溢出问题需要注意，四个数相加太大，那么移到右边变成减法

```C++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        //先排序
        sort(nums.begin(),nums.end());

        //两重循环，固定前面两个数
        for(int i = 0; i < nums.size();++i){
            //去重
            if(i > 0 && nums[i] == nums[i-1])
                continue;
            //固定第二个数
            for(int j = i + 1; j< nums.size();++j){
                if(j > i + 1 && nums[j] == nums[j-1])
                    continue;
                
                int left = j + 1;
                int right = nums.size()-1;

                while(left < right){
                    //不用 (nums[i] + nums[j] + nums[left] + nums[right]) > target 是因为会溢出
                    if(nums[i] + nums[j] > target - nums[left] - nums[right]){
                        --right;
                    }
                    else if(nums[i] + nums[j] < target - nums[left] - nums[right]){
                        ++left;
                    }
                    else{
                        res.push_back(vector<int>{nums[i],nums[j],nums[left],nums[right]});
                        while(left < right && nums[left] == nums[left+1])
                            ++left;
                        while(left < right && nums[right] == nums[right-1])
                            --right;
                        ++left;
                        --right;
                    }
                }
            }
        }
        return res;
    }
};
```

### [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)

思路：

一开始打算利用三重循环加上 hash 计算，但是三重循环的时间复杂度太高了，O（n3）,主要是hash 法用的不对。

**哈希法**：首先二重循环遍历前两个数组，两两相加，使用 map 记录两数和出现的次数。

再用二重循环遍历后两个数组，在 map 中查找是否存在 0-(c+d) 的，如果存在，获得出现的次数，加到 count 上，时间复杂度O(n2)

为什么可以用哈希法，而不是指针法？？因为不是在一个数组里面找，不能排序，而且不需要去重！！！

```C++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        int count = 0;
        //定义一个map来保存，前两个数组两两相加的结果
        unordered_map<int,int> temp_map;

        //前两个数组两两相加，记录所有和出现的次数
        for(int a : nums1){
            for(int b : nums2){
                temp_map[a+b]++;
            }
        }

        //遍历后两个数组，然后找到 0 - (c+d)
        for(int c : nums3){
            for(int d : nums4){
                auto it = temp_map.find(0 - (c+d));
                if(it != temp_map.end()){
                    //count 加上 所有符合条件的个数
                    count += it->second;
                }
            }
        }
        return count;

    }
};
```

# 字符串

## 双指针

利用双指针的方法，处理字符串，通常处理字符串的反转，快慢指针的赋值

### [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

思路：

原地逆转，不能使用额外的空间，使用双指针，从两端向中间移动。移动过程中进行 字符的交换

```C++
class Solution {
public:
    void reverseString(vector<char>& s) {
        //双指针？
        int left = 0;
        int right = s.size()-1;
        while(left < right){
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;

            ++left;
            --right;
        }
    }
};
```

### [541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

思路：

一开始有点不太明白，但其实模拟一下会发现，每次都是从0、2K、4K处开始反转，然后向后反转K个字符。所以 i += 2K。

另外一开始觉得 i 的范围，用了复杂的表达式来计算，但是不管怎么说，肯定是小于 s.size() 的。

可以另外写一个反转函数，来反转传入的字符串 起始位置后的K个字符。

```C++
class Solution {
public:
    //写一个函数用来反转 a 开始后 k 个字符串
    void reverse(string& s,int a,int k){
        int left = a;
        int right = a + (k-1);
        if(right > s.size()-1)
            right = s.size()-1;
        while(left < right){
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            ++left;
            --right;
        }
    }

    string reverseStr(string s, int k) {
        //遍历字符串，每次在 0，2K，4K处开始向后反转 k 个字符串
        for(int i = 0; i < s.size(); i += 2*k){
            reverse(s,i,k);
        }
        return s;
    }
};
```

### [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

思路：

第一眼看，感觉就是直接遍历找到空格，然后替换“%20”，但是发现这是三个字符，而空格只能替换一个字符，因此需要把后面的字符向

后移动，但是太过麻烦。

**法一：另外创建一个字符串** 然后将原字符串的字符一个个移动过去，碰到空格，再进行处理

**法二：原地修改** 原地修改的方法首先统计出字符串中空格的个数，然后将字符串扩容，这时候空间足够了（后面的空的）。

在原地使用双指针进行复制，从前面依然会需要移动后面的字符，所以需要从后面进行操作。

**其实很多数组填充类的问题，都可以先预先给数组扩容到填充后的大小，然后再从后向前进行操作。**

```C++
/******************* 另外一个字符串 ***********************/
class Solution {
public:
    string replaceSpace(string s) {
        string str;
        for(int i = 0; i<s.size();++i){
            if(s[i] == ' '){
                str += "%20";
            }
            else{
                str += s[i];
            }
        }
        return str;
    }
};
/******************* 原地修改 ***********************/
class Solution {
public:
    string replaceSpace(string s) {
        //首先遍历一遍，得出空格的个数，然后进行扩容
        int count = 0;
        int sOldsize = s.size();
        for(int i = 0;i<s.size();++i){
            if(s[i] == ' ')
                ++count;
        }

        //扩容
        s.resize(s.size() + (count * 2));
        int sNewsize = s.size();

        //从后向前遍历
        for(int j = sNewsize - 1,k = sOldsize - 1; j > 0 ;){
            if(s[k--] == ' '){
                s[j--] = '0';
                s[j--] = '2';
                s[j--] = '%';
            }
            else{
                s[j--] = s[k];
            }
        }
    }
};
```

### [151. 颠倒字符串中的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

思路：

一开始有点麻烦，反转还好，主要是在处理反转的同时还要处理空格，这样代码就会变的非常复杂，而且思路也容易乱。

那么可以考虑先把多余的空格去掉，然后再进行反转就会方便一点。

写去除空格的函数也有点麻烦，可以参考[去除数组中指定的元素](https://leetcode-cn.com/problems/remove-element/)的方法，同样是原地去除指定的空格，使用双指针法。**也即数组的第二题**

可以分成三种情况进行处理，前面的、中间的、末尾的空格。判断条件需要想一想。

去除空格之后，将每个单词反转，并且最后整体反转一次。

```C++
class Solution {
public:
    //定义一个反转函数，用来反转
    void reverse(string& s,int left,int right){
        if(right > s.size()-1)
            right = s.size()-1;

        while(left < right){
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            //移动
            ++left;
            --right;
        }
    }

    //去除多余的空格
    void removeSpace(string& s){
        //双指针
        int slowindex = 0,fastindex = 0;
        //去掉前面的空格
        while(s[fastindex] == ' '){
            fastindex++;
        }

        //去掉中间的空格，把空格当成正常复制，多的不能复制
        for(;fastindex < s.size();++fastindex){
            if(s[fastindex] == ' ' && s[fastindex-1] == ' ')
                continue;
            else
                s[slowindex++] = s[fastindex];
        }

        //去掉末尾的空格,注意此时 slowindex已经在后面一个位置了
        //并且 resize 的参数是 元素的个数！！！最后一个元素的后一位
        if(s[slowindex - 1] == ' ')
            s.resize(slowindex-1);
        else
            s.resize(slowindex);
    }

    string reverseWords(string s) {
        //首先去除空格
        removeSpace(s);

        //定义初始位置和结束位置
        int start = 0,end = 0;
        //循环遍历
        for(int i = 0;i < s.size();++i){
            if(s[i] == ' '){
                end = i - 1;
                reverse(s,start,end);
                start = i + 1;
            }

        }
        //最后一个单词没有空格，单独进行反转
        reverse(s,start,s.size()-1);
        //将整个句子全部反转
        reverse(s,0,s.size()-1);
        return s;
    }
};
```

### [剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

思路：

老朋友了这题，先反转前面的，再反转后面的，最后全部反转

局部反转+整体反转

```C++
class Solution {
public:
    //首先定义反转函数
    void reverse(string& s,int start,int end){
        while(start < end){
            swap(s[start],s[end]);
            ++start;
            --end;
        }
    }

    string reverseLeftWords(string s, int n) {
        //前面反转
        reverse(s,0,n-1);
        //后面反转
        reverse(s,n,s.size()-1);
        //全部反转
        reverse(s,0,s.size()-1);
        return s;
    }
};
```

## KMP

主要思想就是当碰到两个指针所指位置的字母不同时，需要看前面一个的 next 数组，回退到前面的位置

- 首先求出长数组的next数组，求next数组的过程看做是匹配的过程

- 然后根据next数组进行匹配

### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

思路：

KMP

```c++
class Solution {
public:
    //构造next数组函数
    void getnext(const string& s, vector<int>& next){
        next[0] = -1;
        //可以把求 next 数组的过程也看成 字符串的匹配过程，i 主串，j 就是模式串
        //需要先判断不相等的情况，如果先判断相等的情况，否则j++了，但是 i 并没有++
        //此时再判断它们不相等的情况就会出现问题
        for(int i = 1,j = -1; i < s.size(); ++i){
            //如果s[i] 和 s[j+1]不相等的话，j 就需要移动，看前面一个位置(j)的next数组
            // j = next[j], 然后继续看 j+1 是否和 i 相等
            // j >= 0 是保证数组是有意义的
            while(j >= 0 && s[i] != s[j+1]){
                j = next[j];
            }

            //如果相等，那就向后移动
            if(s[i] == s[j+1]){
                ++j;
            }
            next[i] = j;
        }
    }
    int strStr(string haystack, string needle) {
        //如果 haystack 是空，直接返回0
        if(haystack.size() == 0)
            return 0;
        //如果 needle 长度比 haystack 长，直接返回
        if(needle.size() > haystack.size())
            return -1;
        vector<int> next(haystack.size());
        //获得next数组
        getnext(needle, next);
        
        for(int i = 0, j = -1; i < haystack.size(); ++i){
            while(j >= 0 && haystack[i] != needle[j+1]){
                j = next[j];
            }

            if(haystack[i] == needle[j+1]){
                ++j;
            }
            
            if(j == (needle.size()-1))
                return (i-j);
        }                       
        return -1;         
    }
};
```

### [459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)

思路：

KMP

```C++
class Solution {
public:
    //构建next 数组
    void getNext(const string& s,int* next){
        int j = -1;
        next[0] = j;
        for(int i = 1;i<s.size();++i){
            //可以把求 next 数组的过程也看成 字符串的匹配过程，i 主串，j 就是模式串
            //当i 所指的和 j+1 不一样时，这时就看前一个位置的 next[j],用来回退
            //回退的过程中，因为 要保证数组不能越界，所以 j >= 0
            while( j >= 0 && (s[i] != s[j+1])){
                j = next[j];
            }
            //如果 i 所指的和 j+1 是一样的话，那么就 j 就向后移动
            if(s[i] == s[j+1]){
                ++j;
            }
            //将 后缀匹配的 前缀长度 记录到 next 数组
            next[i] = j;
        }
    }
    bool repeatedSubstringPattern(string s) {
        int next[s.size()];
        getNext(s,next);

        //如果公共前后缀是 长度的 整数倍，那就是由重复子串构成
        int len = s.size();
        if(next[len-1] != -1 && len%(len - (next[len-1] + 1)) == 0)
            return true;
        
        return false;
    }
};
```



# 栈和队列

### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

思路：

两个栈实现一个队列，就是先放进一个栈A中，在把A中的数据放到B中，此时B的出栈顺序就是队列的顺序

注意到只有当栈 B 中没有数据时，才从栈 A 中转移数据到 栈B。同时先处理是空的情况，这样后面处理不是空的情况就可以一起处理

```C++
class MyQueue {
public:
    //创建两个栈
    stack<int> stA;
    stack<int> stB;
    MyQueue() {
        
    }
    
    void push(int x) {
        stA.push(x);
    }
    
    int pop() {
        //如果第二个栈中没有数据才把第一个栈的数据转移
        //先处理是空的情况，这样后面处理不是空的情况就可以一起处理
        if(stB.empty()){
            while(!stA.empty()){
                stB.push(stA.top());
                stA.pop();
            }
        }
        //此时说明栈中有数据（可能是之前的，也可能是新转移的）
        int res = stB.top();
        stB.pop();
        return res;
    }
    
    int peek() {
        //复用 pop（）
        int res = this->pop();
        // 把pop()出的结果放回来，然后返回
        stB.push(res);
        return res;
    }
    
    bool empty() {
        if(stA.empty() && stB.empty())
            return true;
        else
            return false;
    }
};
```

### [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

思路：

用队列实现栈，两个队列的用法和 用队列实现栈不一样

两个队列 Q1、Q2，元素都放到Q1里面，当需要 pop 时，将Q1的元素，除了最后一个，全部都移动到Q2，然后将Q1的最后一个元素 pop（）。再把Q2里面的元素全部移动到 Q1。

一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。

> queue 单向队列、deque 双向队列

```C++
class MyStack {
public:
    queue<int> Q1;
    queue<int> Q2;

    MyStack() {

    }
    
    void push(int x) {
        Q1.push(x);
        
    }
    
    int pop() {
        //先把最后一个前面的移到 Q2，然后在移动到Q1
        while(Q1.size() != 1){
            Q2.push(Q1.front());
            Q1.pop();
        }
        int res = Q1.front();
        Q1.pop();

        while(!Q2.empty()){
            Q1.push(Q2.front());
            Q2.pop();
        }
        return res;
    }
    
    int top() {
        return Q1.back();
    }
    
    bool empty() {
        if(Q1.empty())
            return true;
        else
            return false;
    }
};
```

### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

思路：

如果是左括号就入栈，然后是右括号在一个一个判断是不是相应的左括号，那这样就慢了

如果是左括号，就入栈相应的右括号，那么后续判断的时候，就不需要对应了，只需要判断栈顶元素和 s[i] 的值是否相等就行了

最后返回的时候，返回栈是否是空，恰好出栈完就是对的

```C++
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        //只要是左括号就入栈相应的右括号，后续只需要判断栈顶和 s[i] 是否相等就行了
        for(int i = 0; i < s.size(); ++i){
            if(s[i] == '(')         st.push(')');
            else if(s[i] == '{')    st.push('}');
            else if(s[i] == '[')    st.push(']');
            else if(!st.empty() && s[i] == st.top())   st.pop();
            else    return false;
        }
        
        //直接返回是否是空就行了，是空就是true
        return st.empty();
    }
};
```

### [1047. 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)

思路：

和括号匹配一样的思路，利用栈来进行相同字符的消除，出栈之后反转一下。

```C++
class Solution {
public:
    string removeDuplicates(string s) {
        stack<char> st;
        for(int i = 0; i < s.size(); ++i){
            if(!st.empty() && s[i] == st.top())
                st.pop();
            else
                st.push(s[i]);
        }
        string str;
        while(!st.empty()){
            str += st.top();
            //str.push_back(st.top());
            st.pop();
        }
        //算法自带的反转函数
        reverse(str.begin(), str.end());
        return str;
    }
};
```

### [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

思路：

主要就是将 字符串转成数字放入到栈中，使用 stoi（）函数。

碰到运算符的时候，取出后面两个数（注意哪个是 num1 和 num2），然后根据运算符运算

```C++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        //遍历每个元素，如果是运算符，进行运算，否则放到栈中
        for(int i = 0; i < tokens.size(); ++i){
            if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/"){
                //获得两个操作数
                int num2 = st.top();
                st.pop();
                int num1 = st.top();
                st.pop();
                //根据符号进行四则运算
                if(tokens[i] == "+")    st.push(num1 + num2);
                else if(tokens[i] == "-")   st.push(num1 - num2);
                else if(tokens[i] == "*")   st.push(num1 * num2);
                else    st.push(num1 / num2);
            }
            else
                st.push(stoi(tokens[i]));
        }
        return st.top();
    }
};
```

### [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

思路：

使用队列来当做滑动窗口，但是如何返回队列里面的最大值呢？

因此定义一个单调队列，让队列里面的元素是有序的，从大到小排列，那么**队头元素就是队列里面的最大值**，直接获得即可

需要自己定义单调队列，常用的功能有哪些需要自己设计？获取队头元素front、插入元素push、删除元素pop

> front()：直接返回队头元素即可
>
> push()：因为需要保证队列是有序的，那么插入时候需要判断队尾元素是否比该元素小，若队尾小，则出队，直到找到大于等于它的元素
>
> pop()：这个也需要设计是当出队的元素是队头元素，说明此时滑动窗口已经要放弃这个元素了，要出队，否则不出队

对于整个数组的遍历需要先把前 K 个元素放到滑动窗口中，找出最大的

然后在后续的遍历中，依照 先出队，然后进队，选出最大 这种顺序，依次遍历

```C++
class Solution {
public:
    class Myqueue{
    public:
        deque<int> _Q;
        int front(){
            return _Q.front();
        }
        //保证队列中的元素是从大到小排列的，
        //当遇到一个元素时，先判断队尾元素和它的大小，若队尾元素小，队尾直接出队，直到队尾元素比它大
        void push(int x){
            while(!_Q.empty() && _Q.back() < x){
                _Q.pop_back();
            }
            _Q.push_back(x);
        }
        
        //出元素的时候判断,是否是队头元素，不是就不出队列
        void pop(int x){
            if(!_Q.empty() && _Q.front() == x)
                _Q.pop_front();
        }
    };
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        Myqueue Q;
        vector<int> res;

        //先把前K个放进去，并且找到最大的
        for(int i = 0; i < k; ++i)
            Q.push(nums[i]);
        res.push_back(Q.front());
        //遍历，每一次进入一个元素，同时出一个元素，保持平衡
        for(int j = k; j < nums.size(); ++j){
            //出队一个
            Q.pop(nums[j-k]);
            //入队一个
            Q.push(nums[j]);
            //返回队头元素
            res.push_back(Q.front());
        }
        return res;
    }
};
```

### [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

思路：

首先需要使用map统计每个元素出现的次数，如何根据map的value进行排序？

因为map的数据可以当成pair，放入到vecor中，再根据自定义的排序仿函数进行排序，根据出现的次数从大到小排列

也可以使用优先队列，C++有优先队列这种东西，其内部实现就是堆，可以自行选择大根堆或者小根堆。

然后就是选择小根堆！！！而不是大根堆。因为小根堆可以保证堆顶下面的数，一定都比堆顶大，最后的K个数就是最大的前K个数。如果是大根堆，堆顶是最大的，而下面的都比较小。

- 其次就是优先队列的创建，<元素类型，放置元素的容器，定义的排序仿函数>

```C++
/**************************************    根据map转为vec排序		*********************************/
class Solution {
public:
    //自定义的排序规则
    class Mycompare{
    public:
        bool operator() (const pair<int, int> lhs, const pair<int, int> rhs) {
            return lhs.second > rhs.second;
        }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        //首先遍历，使用map保存每个数字出现的次数
        unordered_map<int, int> un_map;
        for(int i = 0; i < nums.size(); ++i){
            un_map[nums[i]]++;
        }

        //然后把map的key、value组成 pair 放入到vector中
        vector<pair<int, int>> vec(un_map.begin(), un_map.end());
        //vector 根据自定义的规则，对出现的次数从小到大进行排列
        sort(vec.begin(), vec.end(), Mycompare());
        
        vector<int> res;
        //取前K个高频的数字
        for(int i = 0; i < k; ++i){
            res.push_back(vec[i].first);
        }
        return res;
    }
};
/***********************************		优先队列		***********************************/
class Solution {
public:
    //仿函数，用来建立小根堆
    class Mycompare{
    public:
        bool operator()(const pair<int,int>& map1,const pair<int,int>& map2){
            return map1.second > map2.second;
        }
    };

    vector<int> topKFrequent(vector<int>& nums, int k) {
        //定义一个 map 保存数出现的频率
        unordered_map<int,int> temp_map;
        vector<int> res(k);
        for(int num : nums){
            temp_map[num]++;
        }

        //根据频率排序，建立优先级队列
        priority_queue<pair<int,int>,vector<pair<int,int>>,Mycompare> priq;

        //遍历map，把里面的键值对放入到队列中，选择前K个
        for(unordered_map<int,int>::iterator it = temp_map.begin();it!=temp_map.end();++it){
            priq.push(*it);
            if(priq.size() > k){
                priq.pop();
            }
        }

        //最后根据出现频率输出
        for(int i = 1; i <= k; ++i){
            res[k-i] = priq.top().first;
            priq.pop();
        }
        return res;
    }
};
```

# 二叉树

1、带有返回值的函数，可以不用接收返回值！！！

2、注意区分高度和深度的概念，高度是从该节点到叶子结点，深度是从根节点到该节点。求深度是从上到下遍历，使用前序遍历。而求高度则是从下往上，使用后序遍历。

3、递归的时候，如果判断了该节点是否为空，那么下面可以直接传入。否则，在下面递归传入的时候，需要判断节点不为空才能传

### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

思路：

经典的前序遍历，递归法的**返回值**是什么，**参数**是什么，**终止条件**是什么，**处理逻辑**是什么

迭代法需要使用栈辅助，先把根节点入栈（如果不是空的情况下），然后while循环里的处理逻辑，取出栈顶元素处理，然后把右孩子，左孩子依次入栈。右孩子先近栈，后出栈

```C++
/*****************************   递归法    *********************************/
class Solution {
public:
    vector<int> res;
    //定义前序遍历的递归函数
    void pretraversal(TreeNode* root){
        //终止条件
        if(root == NULL)
            return;
        //处理 中 的节点
        res.push_back(root->val);
        //遍历左孩子
        pretraversal(root->left);
        //遍历右孩子
        pretraversal(root->right);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        pretraversal(root);
        return res;
    }
};
/******************************     迭代法      ********************************/
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        //如果树是空的
        if(root == NULL)
            return vector<int>{};
        vector<int> res;
        //迭代法需要使用栈来辅助
        stack<TreeNode*> st;
        //把根节点入栈
        st.push(root);
        //循环取得栈中的节点
        while(!st.empty()){
            //取出栈顶结点
            TreeNode* node = st.top();
            st.pop();

            //处理 中 节点
            res.push_back(node->val);
            //如果有右孩子，把右孩子进栈
            if(node->right != NULL)
                st.push(node->right);
            //如果有左孩子，把左孩子进栈
            if(node->left != NULL)
                st.push(node->left);
        }
        return res;
    }
};
```

### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

思路：

后序遍历的迭代法有点东西，其顺序是 左、右、中，其实就是 中、右、左反过来，那么其实就和前序遍历的方法一样，最后结果数组反转一下就行

```C++
/*************************        递归法       ************************/
class Solution {
public:
    vector<int> res;
    void postTraversal(TreeNode* root){
        //终止条件
        if(root == NULL)
            return;
        //左
        postTraversal(root->left);
        //右
        postTraversal(root->right);
        //中
        res.push_back(root->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        postTraversal(root);
        return res;
    }
}; 
/***********************        迭代法          ***********************/
class Solution {
public:
    //前序遍历：中，左，右      后序遍历：左，右，中，其实就是中右左反过来
    vector<int> postorderTraversal(TreeNode* root) {
        //如果树是空
        if(root == NULL)
            return vector<int>{};
        vector<int> res;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()){
            //获得栈顶元素，并出栈
            TreeNode* node = st.top();
            st.pop();

            //处理中
            res.push_back(node->val);
            //左入栈
            if(node->left)
                st.push(node->left);
            //右入栈
            if(node->right)
                st.push(node->right);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

思路：

迭代法不仅需要栈辅助，还需要一个全局指针辅助

先向左下角找，如果节点不是空，那么就入栈，并且指向左孩子，直到左孩子为空

此时栈顶元素就是中节点，相当于左节点就是空了，然后取出栈顶元素进行处理，然后让指针指向该节点的右孩子

```C++
/******************        递归        ***********************/
class Solution {
public:
    vector<int> res;
    void inTraversal(TreeNode* root){
        if(root == NULL)
            return;
        //左
        inTraversal(root->left);
        //中
        res.push_back(root->val);
        //右
        inTraversal(root->right);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        inTraversal(root);
        return res;
    }
}; 
/******************            迭代        ***********************/
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        
        TreeNode* cur = root;
        //加上 cur != NULL 的条件是因为想让根节点和其他节点一样处理
        //如果根节点先入栈，然后不加条件，那么如果根节点不空，还会进栈一次
        while(cur != NULL || !st.empty()){
            //如果该节点不空，就让该节点进栈，访问左孩子
            if(cur != NULL){
                st.push(cur);
                cur = cur->left;
            }
            else{
                //如果该节点是空，说明没有左孩子，栈顶元素就是中节点
                TreeNode* node = st.top();
                st.pop();
                res.push_back(node->val);
                //让该节点指向右孩子
                cur = node->right;
            }
        }
        return res;
    }
};
```

### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

连打十题

- 102.二叉树的层序遍历
- 107.二叉树的层次遍历II
- 199.二叉树的右视图
- 637.二叉树的层平均值
- 429.N叉树的层序遍历
- 515.在每个树行中找最大值
- 116.填充每个节点的下一个右侧节点指针
- 117.填充每个节点的下一个右侧节点指针II
- 104.二叉树的最大深度
- 111.二叉树的最小深度

思路：

队列辅助，获得每一层的数量，然后依次出队列，同时把下一层的节点入队

```C++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        //如果是空树
        if(root == NULL)
            return vector<vector<int>>{};
        //需要定义队列辅助
        queue<TreeNode*> Q;
        vector<int> temp;
        vector<vector<int>> res;
        //让根节点先进队列
        Q.push(root);

        //总循环
        while(!Q.empty()){
            //获得当前的size
            int size = Q.size();
            //收集之前先清零
            temp.clear();
            //进行每一层的循环,每一层存到temp中
            while(size--){
                //获得队头元素并出队
                TreeNode* node = Q.front();
                Q.pop();

                //处理
                temp.push_back(node->val);
                //左孩子
                if(node->left)
                    Q.push(node->left);
                //右孩子
                if(node->right)
                    Q.push(node->right);
            }
            //获得一层的所有元素后，存到结果数组
            res.push_back(temp);
        }
        return res;
    }
};
```

### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

思路：

类似于之前的遍历，只是改变中间的处理逻辑（相当于之前遍历到每个节点，然后交换每个节点的左右孩子）

```C++
/**********************        递归法       **********************/
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        //终止条件
        if(root == NULL)    return NULL;
        //左
        invertTree(root->left);
        //右
        invertTree(root->right);
        //中,处理逻辑
        swap(root->left, root->right);
        return root;
    }
}; 
/**********************        迭代法       **********************/
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == NULL)    return NULL;
        stack<TreeNode*> st;
        st.push(root);

        while(!st.empty()){
            TreeNode* node = st.top();
            st.pop();
            //改变的只是这里的处理逻辑，对中节点的处理
            swap(node->left, node->right);
            if(node->left)  st.push(node->left);
            if(node->right) st.push(node->right);
        }
        return root;
    }
};
```

### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

思路：

> 返回值：bool
>
> 参数：两个节点（为什么会想到用两个节点）
>
> 终止条件：终止条件就是两个节点先进行比较，如果不满足直接返回，同时也在排除两节点是空的情况
>
> 处理逻辑：后续遍历，根据两节点自身情况和它们下面节点的情况判断

```C++
/******************************         递归法          *********************/
class Solution {
public:
    //自己定义一个函数，传入两个节点
    bool isEqual(TreeNode* left, TreeNode* right){
        //对于两个节点来说，要想判断它是否是轴对称的，那么不仅需要判断其下面是否是对称的，还需要判断两个节点自己
        //终止条件
        //如果两个节点本身都不是对称的，那就不需要看它们下面的节点是否对称了
        //榆次同时也是在排除节点是空的情况，方便后续遍历孩子结点
        if(left == NULL && right != NULL)   return false;
        else if(left != NULL && right == NULL)  return false;
        else if(left == NULL && right == NULL)  return true;
        else if(left->val != right->val)    return false;

        bool leftbool = isEqual(left->left, right->right);
        bool rightbool = isEqual(left->right, right->left); 
        
        return (leftbool && rightbool);       
    }
    //从根节点分化成两个指针，分别向下移动
    bool isSymmetric(TreeNode* root) {
        if(root == NULL)    return true;
        return isEqual(root->left, root->right);
    }
};
```

### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

思路：

求深度，按照正常来说，使用前序遍历，把每层的深度当做参数不断向下传，找到最大的深度

但是，其实也是根节点的高度，也能使用后序遍历，最后返回根节点的高度

```C++
/************************     有点像求高度         ************************/
class Solution {
public:
    int maxDepth(TreeNode* root) {
        //终止条件
        if(root == NULL)    return 0;
        //左
        int left = maxDepth(root->left);
        //右
        int right = maxDepth(root->right);
        //中，处理逻辑
        return max(left, right) + 1;
    }
}; 
/************************     前序遍历，真正的求深度         ************************/
class Solution {
public:
    int maxdepth = 0;
    void preTraversal(TreeNode* root, int depth){
        if(root == NULL)    return;
        //中，处理逻辑
        maxdepth = max(maxdepth, depth);
        //左
        preTraversal(root->left, depth + 1);
        //右
        preTraversal(root->right, depth + 1);
    }
    int maxDepth(TreeNode* root) {
        preTraversal(root, 1);
        return maxdepth;
    }
};
/************************     层序遍历         ************************/
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == NULL)
            return 0;
        //定义一个队列来放指针
        queue<TreeNode*> Q;
        int depth = 0;
        Q.push(root);
        while(!Q.empty()){
            int size = Q.size();
            depth++;
            for(int i = 0;i<size;++i){
                //获得队头元素 然后出队
                TreeNode* node = Q.front();
                Q.pop();             
                if(node->left)  Q.push(node->left);
                if(node->right) Q.push(node->right);
            }
        }
        return count;
    }
};
```

### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

思路：

和最大深度类似

```C++
/******************     层序遍历        ************************/
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root == NULL)    return 0;
        queue<TreeNode*> Q;
        int res = INT_MAX;
        int depth = 0;
        Q.push(root);

        while(!Q.empty()){
            int size = Q.size();
            depth++;
            while(size--){
                TreeNode* node = Q.front();
                Q.pop();
                //如果是叶子结点
                if(node->left == NULL && node->right == NULL){
                    res = min(res, depth);
                    continue;
                }
                if(node->left)  Q.push(node->left);
                if(node->right) Q.push(node->right);
            }
        }
        return res;
    }
};
/******************     递归，前序        ************************/
class Solution {
public:
    int res = INT_MAX;
    void pretraversal(TreeNode* root, int depth){
        //终止条件
        if(root->left == NULL && root->right == NULL){
            res = min(res, depth);
        }
        //因为终止条件改了，这里要保证需要判断的节点不能是空
        if(root->left)  pretraversal(root->left, depth+1);
        if(root->right) pretraversal(root->right, depth+1);
    }
    int minDepth(TreeNode* root) {
        if(root == NULL)    return 0;
        pretraversal(root, 1);
        return res;
    }
};
/*******************************		递归， 后序遍历		****************************/
class Solution {
public:

    int getminDepth(TreeNode* node){
        if(node == NULL)
            return 0;
        //获得左右节点的最小深度
        int leftdepth = getminDepth(node->left);
        int rightdepth = getminDepth(node->right);
        //根据情况判断用哪个作为返回值
        if(node->left == NULL && node->right != NULL)
            return rightdepth + 1;
        if(node->left != NULL && node->right == NULL)
            return leftdepth + 1;

        return min(leftdepth,rightdepth) + 1;

    }

    int minDepth(TreeNode* root) {
        return getminDepth(root);
    }
};
```

### [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

思路：

当成普通二叉树，遍历左右节点，统计节点个数

当成完全二叉树，如果其不是满二叉树，那么向下遍历，其左右子树有可能是满二叉树，最后加上去即可

首先定义两个指针，分别沿着最左边和最右边，看深度是否一样，是满二叉树就按照公式计算，不是就遍历其左右子树

```C++
/**********************************		普通二叉树		*********************************/
class Solution {
public:
    int res = 0;
    void pretraversal(TreeNode* root){
        if(root == NULL)    return;
        res++;
        pretraversal(root->left);
        pretraversal(root->right);
    }
    int countNodes(TreeNode* root) {
        pretraversal(root);
        return res;
    }
};
/**********************************		完全二叉树		*********************************/
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == NULL)    return 0;
        //定义两个指针，分别沿着最左边和最右边，看深度是否一样
        TreeNode* left = root->left;
        TreeNode* right = root->right;

        int leftHeight = 0;
        int rightHeight = 0;
        while(left){
            left = left->left;
            leftHeight++;
        }
        while(right){
            right = right->right;
            rightHeight++;
        }
        //判断是否相等,是否是满二叉树
        if(leftHeight == rightHeight){
            //2的次方运算，就相当于移位运算
            return (2 << leftHeight) - 1;
        }
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

### [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

思路：

对于一棵树，要想判断其是否平衡，需要左右子树的高度，那么就需要函数来获得每个节点的高度。

那么如何表示失衡呢，和正常高度的返回值不同就行。返回值是 -1 就代表失衡

对于一个节点，如果左右子树已经失衡，则就是失衡了，如果左右子树高度差小于等于1，平衡，选择较大的高度当做高度。否则，失衡

```C++
class Solution {
public:
    int posttraversal(TreeNode* root){
        //终止条件
        if(root == NULL)    return 0;

        //左
        int leftHeight = posttraversal(root->left);
        //右
        int rightHeight = posttraversal(root->right);
        //中，处理逻辑
        //如果左右子树不是平衡的，直接返回-1
        //如果两个子树高度差小于等于1，那么选择较高的当做当前节点的高度
        //否则，说明高度差大于1，返回-1
        if(leftHeight == -1 || rightHeight == -1)
            return -1;
        else if(abs(leftHeight-rightHeight) <= 1)
            return max(leftHeight, rightHeight) + 1;
        else
            return -1;
    }
    bool isBalanced(TreeNode* root) {
        return posttraversal(root) == -1 ? false : true;
    }
};
```

### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

思路：



```C++
class Solution {
public:
    vector<string> res;
    void getpath(TreeNode* root, string s){
        //终止条件
        if(root->left == NULL && root->right == NULL){
            res.push_back(s);
            return;
        }
        //遍历孩子结点,每个节点此时的字符串就是刚好的顺序，
        //在传入下一个节点的时候，因为并没有改变 s 的值，所以其实就相当于回溯了
        if(root->left)  getpath(root->left, s +"->" + to_string(root->left->val));
        if(root->right) getpath(root->right, s + "->" + to_string(root->right->val));
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        string str;
        //先判断 根节点是否是空节点
        if(root == NULL)
            return res;
        //先把根节点放入
        str += to_string(root->val);
        getpath(root, str);
        return res;
    }
};
```

### [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

思路：

难点在于需要判断该叶子结点是父节点的左孩子，而不能是右孩子

1、前序遍历：传入两个节点，一个自身，一个父节点，终止条件不仅判断自己是否是叶子结点，还需要判断是否是左孩子

2、后序遍历：先获得左右子树的左叶子之和，如果该节点的左孩子存在，并且是叶子结点，那么需要加上 midvalue

```C++
/*********************************			递归法，前序遍历		*****************************/
class Solution {
public:
    int sum = 0;
    void sumLeft(TreeNode* node, TreeNode* pre){
        //终止条件
        //1、该节点是叶子结点，2、它是父节点的左节点
        if(node->left == NULL && node->right == NULL && node == pre->left){
            sum += node->val;
        }

        if(node->left)  sumLeft(node->left, node);
        if(node->right) sumLeft(node->right, node);
    }
    int sumOfLeftLeaves(TreeNode* root) {
        if(root == NULL)    return 0;
        
        if(root->left)  sumLeft(root->left, root);
        if(root->right) sumLeft(root->right, root);
        return sum;
    }
};
/*********************************			递归法，后序遍历		*****************************/
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(root == NULL)    return 0;
        int leftValue = sumOfLeftLeaves(root->left);        //左
        int rightValue = sumOfLeftLeaves(root->right);      //右
                                                            //中
        int midValue = 0;
        //如果有左节点，并且左节点是叶子结点
        if(root->left && root->left->left == NULL && root->left->right == NULL){
            midValue += root->left->val;
        }
        return leftValue + rightValue + midValue;
    }
};
```

### [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

思路：

1、递归法：类似求每个节点的深度，如果当前的深度的最大的，那么就更新结果的值（因为是先遍历左子树，所以最后一层一定是最左边的节点先访问）

2、迭代法：层序，用每次队列里面的第一个值更新

```C++
/**********************************			递归、前序遍历		*******************************/
class Solution {
public:
    int maxDepth = 0;
    int res = 0;
    void leftValue(TreeNode* node, int depth){
        //终止条件
        if(node == NULL)
            return;
        
        if(depth > maxDepth){
            maxDepth = depth;
            res = node->val;
        }

        leftValue(node->left, depth + 1);
        leftValue(node->right, depth + 1);
    }
    int findBottomLeftValue(TreeNode* root) {
        leftValue(root, 1);
        return res;
    }
};
/**********************************			层序遍历		*******************************/
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        if(root == NULL)    return 0;
        queue<TreeNode*> Q;
        int leftValue = 0;
        Q.push(root);

        while(!Q.empty()){
            int size = Q.size();
            leftValue = Q.front()->val;
            while(size--){
                TreeNode* node = Q.front();
                Q.pop();

                if(node->left)  Q.push(node->left);
                if(node->right) Q.push(node->right);
            }
        }
        return leftValue;
    }
};
```

### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

思路：

递归法：终止条件就是看叶子结点时，剩余值的情况。

```C++
/****************************************		递归法、后序遍历			*********************************/
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        //这个主要是判断根节点是空的情况
        if(root == NULL)
            return false;
        //减去该节点的值，看是否是 0
        targetSum -= root->val;
        //终止条件
        if(root->left == NULL && root->right == NULL){
            if(targetSum == 0)
                return true;
            else
                return false;
        }

        if(root->left)  
           if(hasPathSum(root->left, targetSum))
                return true;
        if(root->right) 
            if(hasPathSum(root->right, targetSum))
                return true;

        return false;
    }
};
```

## 构造二叉树

使用数组来构造二叉树，通常情况是根据下标来确定起始位置。

### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

思路：

递归的根据中序和后序遍历顺序构造，相对于每次都构造新的 vector 传入，直接使用位置截取更快

```C++
class Solution {
public:
    TreeNode* recurrentbuildTree(vector<int>& inorder, int startinorder, int endinorder, vector<int>& postorder, int startpostorder, int endpostorder){
        //终止条件
        if(startinorder < 0 || startinorder > endinorder)
            return NULL;

        //获得根节点的位置
        int rootVal = postorder[endpostorder];
        int rootindex = 0; 
        for(int i = startinorder; i <= endinorder; ++i){
            if(inorder[i] == rootVal){
                rootindex = i;
                break;
            }
        }
        //获得左子树的中序遍历
        int left_start_inorder = startinorder;
        int left_end_inorder = rootindex - 1;
        int left_len = left_end_inorder - left_start_inorder + 1;
        //获得右子树的中序遍历
        int right_start_inorder = rootindex + 1;
        int right_end_inorder = endinorder;
        //获得左子树的后序遍历
        int left_start_postorder = startpostorder;
        int left_end_postorder = startpostorder + left_len - 1;
        //获得右子树的后序遍历
        int right_start_postorder = left_end_postorder + 1;
        int right_end_postorder = endpostorder - 1;
        //构造完成的左子树根节点
        TreeNode* leftTree = recurrentbuildTree(inorder, left_start_inorder, left_end_inorder, postorder, left_start_postorder, left_end_postorder);
        //构造完成的右子树根节点
        TreeNode* rightTree = recurrentbuildTree(inorder, right_start_inorder, right_end_inorder,postorder, right_start_postorder, right_end_postorder);
        //连接
        TreeNode* root = new TreeNode(rootVal);
        root->left = leftTree;
        root->right = rightTree;
        return root;        
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return recurrentbuildTree(inorder, 0, inorder.size()-1, postorder, 0, postorder.size()-1);
    }
};
```

### [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

思路：

构造二叉树，方法就是找到中间节点，获得左右子树的边界，二分构造

```C++
class Solution {
public:
    TreeNode* buildTree(vector<int>& nums, int start, int end){
        //终止条件
        if(start == end)    return NULL;

        //只找到中间节点
        int index = start + (end-start)/2;
        //获得左子树的边界
        int left_start = start;
        int left_end = index;
        //获得右子树的边界
        int right_start = index + 1;
        int right_end = end;

        TreeNode* root = new TreeNode(nums[index]);
        //构建左子树
        root->left = buildTree(nums, left_start, left_end);
        //构建右子树
        root->right = buildTree(nums, right_start, right_end);

        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return buildTree(nums, 0, nums.size());
    }
};
```

### [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

思路：

找到最大的值和位置，递归的构造左右子树

```C++
class Solution {
public:
    TreeNode* constructTree(vector<int>& nums, int begin, int end){
        //终止条件
        if(begin == end)
            return NULL;
        //寻找最大的值
        int maxValue = 0;
        int index = begin;
        for(int i = begin; i < end; ++i){
            if(nums[i] > maxValue){
                maxValue = nums[i];
                index = i;
            }
        }
        //构建根节点
        TreeNode* root = new TreeNode(maxValue);
        root->left = constructTree(nums, begin, index);
        root->right = constructTree(nums, index+1, end);

        return root;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        //终止条件
        if(nums.size() == 0)
            return NULL;
        return constructTree(nums, 0, nums.size());
    }
};
```

### [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

思路：

递归：构造新树，而不是把一棵树加到另一棵树上面

迭代：不构造新树，直接把一棵树加到另外一棵树上面

```C++
/**************************************			递归法			***********************************/
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        //终止条件
        if(root1 == NULL && root2 == NULL)
            return NULL;
       //1是空，2不是空
        else if(root1 == NULL && root2 != NULL){
            return root2;
        }
       //1不是空，2是空
        else if(root1 != NULL && root2 == NULL){
            return root1;
        }

        //构造新的节点合并二叉树
        TreeNode* root = new TreeNode(root1->val + root2->val);
        root->left = mergeTrees(root1->left, root2->left);
        root->right = mergeTrees(root1->right, root2->right);

        return root;
    }
};
/**************************************			迭代法			***********************************/
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(root1 == NULL && root2 == NULL)  return NULL;
        else if(root1 == NULL && root2 != NULL) return root2;
        else if(root1 != NULL && root2 == NULL) return root1;
        queue<TreeNode*> Q;
        Q.push(root1);
        Q.push(root2);
        while(!Q.empty()){
            //取出两个节点，并相加
            TreeNode* node1 = Q.front();Q.pop();
            TreeNode* node2 = Q.front();Q.pop();
            node1->val += node2->val;

            //如果左节点都存在的话
            if(node1->left && node2->left){
                Q.push(node1->left);
                Q.push(node2->left);
            }
            //如果右节点都存在的话
            if(node1->right && node2->right){
                Q.push(node1->right);
                Q.push(node2->right);
            }
            //因为返回的是 root1 ，所以root1不空，root2为空的情况不需要处理了
            //如果 root1 的左边是空，而 root2 的左边不是空的话，就赋值过去
            if(node1->left == NULL && node2->left != NULL)
                node1->left = node2->left;
            if(node1->right == NULL && node2->right != NULL)
                node1->right = node2->right;
        }
        return root1;
    }
};
```

## 二叉搜索树

具有性质，左子树的最大值小于根节点，右子树的最小值大于根节点

- 一般可以使用中序遍历进行操作
- 或者使用一个前驱结点操作

### [700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

思路：

递归法：搜索树具有性质，左边的比根节点小，右边的比根节点大

迭代法：可以不使用栈，直接类似二分搜索法就行

```C++
/*****************************************		递归法		********************************/
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        //终止条件
        if(root == NULL)    return  NULL;
        //中，处理逻辑
        if(root->val == val)
            return root;
        //左、右
        else if(val > root->val)
            return searchBST(root->right, val);
        else
            return searchBST(root->left, val);
    }
};
/*****************************************		迭代法		********************************/
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(root == NULL)    return NULL;
        stack<TreeNode*> st;

        st.push(root);
        while(!st.empty()){
            TreeNode* node = st.top();
            st.pop();
            //中，处理逻辑
            if(node->val == val)
                return node;
            else if(val > node->val){
                if(node->right)
                    st.push(node->right);
            }
            else
                if(node->left)
                    st.push(node->left);
        }

        return NULL;
    }
};
```

### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

思路：

1、一种想法就是中序遍历，然后判断数组是否是单调递增的

2、递归的时候，中序遍历，记录之前的最大值，然后和中间节点比较，但是初始化成最小值的时候，可能存在某个节点是最小值，因此采用前驱结点，中序遍历的时候，比较前驱节点和中间节点的值。同时也要返回左右子树的递归结果

3、迭代法，中序遍历

```C++
/************************       中序遍历法      ****************/
class Solution {
public:
    vector<int> res;
    void inorderTraversal(TreeNode* root){
        if(root == NULL)    return;
        
        inorderTraversal(root->left);
        res.push_back(root->val);
        inorderTraversal(root->right);
    }
    bool isValidBST(TreeNode* root) {
        if(root == NULL)    return true;
        inorderTraversal(root);

        for(int i = 1; i < res.size(); ++i){
            if(res[i] <= res[i-1])
                return false;
        }
        return true;
    }
};
/************************       递归前驱指针法      ****************/
class Solution {
public:
    //判断是否是二叉搜索树需要满足两个条件，对于某个节点
    //一个是左右子树都是二叉搜索树
    //另外一个是当前的值要大于前驱结点的值
    TreeNode* pre = NULL;
    bool isValidBST(TreeNode* root) {
        if(root == NULL)    return true;
        bool left = isValidBST(root->left);

        if(pre != NULL && pre->val >= root->val)
            return false;
        pre = root;

        bool right = isValidBST(root->right);
        return left && right;
    }
};
/************************       迭代法，中序遍历      ****************/
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        if(root == NULL)    return true;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL;
        while(cur != NULL || !st.empty()){
            if(cur != NULL){
                st.push(cur);
                cur = cur->left;
            }
            else{
                TreeNode* node = st.top();
                st.pop();

                if(pre != NULL && pre->val >= node->val)
                    return false;
                pre = node;

                cur = node->right;
            }
        }
        return true;
    }
};
```

### [530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

思路：

和上一题一样，因为是二叉搜索树，那么中序遍历的时候是递增的，要想知道两个节点之间的最小值，必然是相邻的两个节点（中序遍历的相邻节点）之间的差值最小，不然随着递增，后面的数减去前面的数会变大，因此，需要全局记录最小值，并用相邻节点的差值不断更新。
可以使用中序遍历得到数组的方式，也可以采用前驱节点记录。

```C++
/*****************************		递归，中序遍历			************************/
class Solution {
public:
    TreeNode* pre = NULL;
    int res = INT_MAX;
    int getMinimumDifference(TreeNode* root) {
        if(root == NULL)    return 0;
        //左边的值,但是不需要
        getMinimumDifference(root->left);
        if(pre != NULL){
            res = min(res, root->val - pre->val);
        }
        pre = root;
        getMinimumDifference(root->right);
        return res;
    }
};
```

### [501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

思路：

- 普通法：

普通法就是不用二叉搜索树的特性，直接遍历一遍树，然后将数值和频率映射到map里面，但是map并不支持 根据 Value 进行排序，所以需要将 key 和 Value 封装成 pair ，然后自己定义规则，根据频率进行排序。

- 二叉搜索树递归法：

因为中序遍历是有序的，那么在中序遍历的时候，保存一个count的数值，记录相等的数出现的次数，如果后面的和前驱结点的值一样，那么count++，如果不一样，说明已经到了下一个数值了，把count重新设置为1
在过程中对count的值进行判断，如果count和目前已知的最大频率相等，那么就把count对应的节点数值加入到结果数组中，但是如果发现更大的count 比目前已知的频率还要大，那么就直接清空结果数组，然后把该节点的值放入到结果数组中

```C++
/********************************   普通方法    ******************************/
class Solution {
public:
    
    //自己定义排序的函数
    bool static Mycompare(const pair<int,int>& a, const pair<int,int>& b){
        return a.second > b.second;
    }
    //遍历树，将其映射到map里
    void searchTree(TreeNode* node,unordered_map<int,int>& map){
        if(node == NULL)    return;
        map[node->val]++;
        searchTree(node->left,map);
        searchTree(node->right,map);
    }
    vector<int> findMode(TreeNode* root) {
        //定义一个map来保存数和出现的频率
        unordered_map<int,int> map;
        //定义一个vector,根据频率数值排序
        vector<pair<int, int>> vec;
        vector<int> res;
        searchTree(root,map);
        //遍历map,把key 和 value 大打包成pair放入到容器中
        for(auto it = map.begin(); it != map.end(); ++it){
            vec.push_back(make_pair(it->first,it->second));
        }
        //对vector 根据定义的规则，即频率排序
        sort(vec.begin(),vec.end(),Mycompare);

        //最后把vector的第一个找出来，后续和他频率一样的也找出来
        res.push_back(vec[0].first);
        for(int i = 1; i < vec.size(); i++){
            if(vec[i].second == vec[0].second)
                res.push_back(vec[i].first);
        }
        return res;
    }
};
/*********************   二叉搜索树递归法   *********************************/
class Solution {
public:
    vector<int> res;
    int count = 1;
    int max_count = INT_MIN;
    TreeNode* pre = NULL;
    void preTraversal(TreeNode* root){
        //终止条件
        if(root == NULL)    return;

        //左子树
        preTraversal(root->left);
        //中，处理逻辑
        if(pre != NULL){
            if(root->val != pre->val)
                count = 1;
            else
                count++;
        }
        if(count == max_count)
            res.push_back(root->val);

        if(count > max_count){
            max_count = count;
            res.clear();
            res.push_back(root->val);
        }
        pre = root;
        //右子树
        preTraversal(root->right);

    }
    vector<int> findMode(TreeNode* root) {
        if(root == NULL)    return vector<int>{};
        preTraversal(root);
        return res;
    }
};
```

### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

思路：

查找两个节点的公共祖先，如果找到了这两个节点，直接返回它们

对于每个中间节点来说，如果左边或者右边有一个存在，返回它们，如果都存在，说明左右子树各有一个，返回这个中间节点

```C++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        //终止条件,如果是空，就返回空，如果是p或者q，就返回它们自身
        if(root == p || root == q || root == NULL)  return root;

        //获得左右子树的情况
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);

        //判断左右子树是否存在 这两个节点
        //如果两个子树都不存在
        if(left == NULL && right == NULL)
            return NULL;
        else if(left != NULL && right == NULL)
            return left;
        else if(left == NULL && right != NULL)
            return right;
        else
            return root;
    }
};
```

### [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

思路：

在二叉搜索树中，如果 p, q，存在于公共节点的左右子树中，那么公共节点的值一定在区间 [p,q] 之间。因此不需要从下到上的回溯法，直接从根节点向下查找就行，找得到返回就行。

注意：一开始并不知道 p,q 值的相对大小

```C++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        //终止条件
        if(root == NULL)   return root;

        //获得区间范围
        int start = min(p->val, q->val);
        int end = max(p->val, q->val);

        if(start <= root->val && root->val <= end)
            return root;
        else if(root->val < start)
            return lowestCommonAncestor(root->right, p, q);
        else
            return lowestCommonAncestor(root->left, p, q);
    }
};
```

## 二叉树的修改 && 二叉搜索树

对二叉树进行插入，删除操作，因为修改了树的结构，可以构造前驱结点。

另一种方法是返回节点自身，然后递归的时候，分别用左右指针接收，如果没变化，就接收正常的左右孩子，否则就接收改变的左右孩子

### [701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

思路：

整体思路就是从上到下遍历，如果遇到空节点，说明找到了这个位置，构造新节点，关键的是如何连接到之前的树上

- 一个简单的想法是维护一个前驱结点，来加入
- 另一个想法是返回新构造的节点，在递归的时候，直接让左右子树指向递归的节点

```C++
/***************************    递归法    *************************************/
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == NULL) {
            TreeNode* node = new TreeNode(val);
            return node;
        }
        //这太妙了
        if (root->val > val) root->left = insertIntoBST(root->left, val);
        if (root->val < val) root->right = insertIntoBST(root->right, val);
        return root;
    }
};
/**************************		自己写的		********************************/
class Solution {
public:
    TreeNode* pre = NULL;
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == NULL && pre == NULL){
            TreeNode* node = new TreeNode(val);
            return node;
        }
        //找到空节点构造
        if(root == NULL && pre != NULL){
            TreeNode* node = new TreeNode(val);
            if(val > pre->val)
                pre->right = node;
            else
                pre->left = node;
            return root;
        }
        //保存前驱结点
        pre = root;
        if(val < root->val){
            insertIntoBST(root->left, val);
        }
        else if(val > root->val){
            insertIntoBST(root->right, val);
        }
        return root;
    }
};
```

### [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

思路：

首先，搜索出该节点，如果找到就进行处理，如果没找到，根据根节点的值选择遍历左或者右子树，并用左右指针接收返回值

如果找到了，还需要对这个节点的左右子树的情况进行讨论

- 如果左右子树都是空
- 如果存在一个不为空
- 两个都不是空，把左子树插入到右子树的最左边的叶子结点，然后返回右子树

```C++
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        //返回右子树的根节点，同时让左子树的根节点放到右子树的最左边的叶子结点
        //终止条件，
        if(root == NULL)    return NULL;
        //如果找到了
        if(key == root->val){
            //如果左右都是空
            //如果左右有一个不是空
            //如果左右都不是空
            if(root->left == NULL && root->right == NULL)       return NULL;
            else if(root->left == NULL && root->right != NULL)  return root->right;
            else if(root->left != NULL && root->right == NULL)  return root->left;
            else{
                TreeNode* node = root->right;
                while(node->left != NULL)
                    node = node->left;
                node->left = root->left;
                return root->right;
            }
            
        }
        //如果没找到，就左右看看,左右孩子就是返回的节点
        else if(key < root->val)
            root->left = deleteNode(root->left, key);
        else    
            root->right = deleteNode(root->right, key);
        return root;

    }
};
```

### [669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)

思路：

不同于前面两题，这题返回的是正确的节点，而**不是**直接删除不符合的节点

整体思路就是寻找符合条件的节点，然后返回。

- 如果根节点小于左区间，那就找右子树
- 如果根节点大于右区间，那就找左子树
- 如果根节点在区间内，那两边都要找

```C++
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if(root == NULL)    return NULL;

        //如果根节点小于左区间
        if(root->val < low)
            return trimBST(root->right, low, high);
        
        //如果根节点大于右区间
        if(root->val > high)
            return trimBST(root->left, low, high);
        
        //如果根节点恰好在区间内
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};
```

### [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

思路：

因为是二叉搜索树，某个节点的右边的节点都是比其大的，因此，这题需要想到逆序遍历，**右中左**的遍历顺序，这样每遍历一个节点，直接让之前的所有和加上自身节点的值就可以了

```C++
class Solution {
public:
    int sum = 0;
    TreeNode* convertBST(TreeNode* root) {
        //终止条件
        if(root == NULL)    return NULL;

        //先遍历右子树
        convertBST(root->right);
        //中，处理逻辑
        sum += root->val;
        root->val = sum;
        //遍历左子树
        convertBST(root->left);
        return root;
    }
};
```

# 回溯算法

## 组合

给定一个数组，然后从数组中计算有多少组合，满足给定的条件。因为是组合问题，顺序不同视为同一个结果，如 [1,3] 和 [3,1] 是同一个结果

使用回溯法的时候，在向下递归时，应从下一个位置开始递归

终止条件根据题目决定

### [77. 组合](https://leetcode.cn/problems/combinations/)

思路：

可以进行剪枝优化，在递归判断的时候，如果剩下的数全拿都不满足 k 个数，就可以返回了

```C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> res;

    void backtracking(int n, int k, int startIndex){
        // 终止条件
        if(path.size() == k){
            res.push_back(path);
            return;
        }

        //回溯算法
        for(int i = startIndex; i <= n; ++i){
            path.push_back(i);
            backtracking(n, k, i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return res;
    }
};
```

### [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)

思路：

```C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(int k, int n, int startIndex){
        //终止条件
        if(path.size() == k && n == 0){
            res.push_back(path);
            return;
        }

        // 递归回溯
        for(int i = startIndex; i <= 9; ++i){
            path.push_back(i);
            backtracking(k, n - i, i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) {
        backtracking(k, n, 1);
        return res;
    }
};
```

### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

思路：

本题是从几个不同的数组中选择字母进行组合。在该轮开始时，需要先确定本次所使用的是哪个位置的字符串，然后对字符串进行从前向后的遍历。

本题不需要额外的位置变量记录遍历时候的位置，当是最后一层的时候，直接就是遍历完，如果不是最后一层，从前向后的过程跳到下一层。（遍历的不是同一个数组）

```C++
class Solution {
public:
    //二维数组建立映射 要从 0 开始进行匹配
    const string map[10] = {
        "",
        "",
        "abc",
        "def",
        "ghi",
        "jkl",
        "mno",
        "pqrs",
        "tuv",
        "wxyz"
    };
    string str;
    vector<string> res;  
    void backtracking(const string& digits, int Index){
        if(str.size() == digits.size()){
            res.push_back(str);
            return;
        }
        //选择哪个数字
        //把字符串数字 转成真的数字
        int digit = digits[Index] - '0';
        //把那个数字对应的字符串取出来
        string s = map[digit];
        //遍历该字符串
        for(int i = 0; i < s.size(); ++i){
            str.push_back(s[i]);
            backtracking(digits, Index + 1);
            str.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        str.clear();
        res.clear();
        if(digits == "")    return res;
        backtracking(digits, 0);
        return res;
    }
};
```

### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

思路：

**注意：该题是无重复元素的！！！！！**
是否需要 startIndex 的问题，如果下一次的取值和之前的没关系就不需要，有关系就需要。本题是有关系的，如果是从0开始，那么存在 2,3和3,2的情况，因此需要 startIndex

终止条件：因为可以无限制的取，所以 target == 0 的情况不够，会出现 target < 0 的情况还会一直执行下去，因此还要加个判断

```C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(const vector<int>& candidates, int target, int startIndex){
        //终止条件
        if(target == 0){
            res.push_back(path);
            return;
        }

        for(int i = startIndex; i < candidates.size() && target > 0; ++i){
            path.push_back(candidates[i]);
            backtracking(candidates, target - candidates[i], i);
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        path.clear();
        res.clear();
        backtracking(candidates, target, 0);
        return res;
    }
};
```

### [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

思路：

**去重：**数组中有重复的数，首先排序让相同的数都在一起，在进行遍历的时候，如果和前面一个数相同，那么需要判断是在一个树层上还是在一个树枝上。如果是树层的话，就不行，如果是树枝，可以取

加入 used 数组初始化为 false，如果不是回溯的更新 used 数组，而是在遍历完后把该次遍历的全部设为 true，那么后面的也会变为 true

而采用回溯的更新 used 数组，那么其实最后并没有改变 used 数组的值

```C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(vector<int>& candidates, int target, int startIndex, vector<bool>& used){
        //终止条件
        if(target < 0)  return;
        if(target == 0){
            res.push_back(path);
            return;
        }
        //说明进行循环, 进行了剪枝，就是说，如果选了当前的值 target < 0 了，就不需要进递归了
        for(int i = startIndex; i < candidates.size() && target-candidates[i] >= 0; ++i){
            //如果这次要取的值是之前取过的，就不取，然后拿下一个值
            if(i > 0 && candidates[i-1] == candidates[i] && used[i-1] == false){
                continue;
            }
            path.push_back(candidates[i]);
            target -= candidates[i];
            used[i] = true;
            backtracking(candidates, target, i+1, used);
            used[i] = false;
            target += candidates[i];
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        path.clear();
        res.clear();
        //根据 candidates 的大小创建 used 容器，并都初始化为 false
        vector<bool> used(candidates.size(), false);
        //进行排序
        sort(candidates.begin(),candidates.end());
        backtracking(candidates, target, 0, used);
        return res;
    }
};
```



## 排列



## 分割

### [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

思路：

回溯法的参数：维护一个指针，从这里开始，然后向后遍历，如果是回文字符串，那么就放入到过程数组中，然后从下一个位置开始，继续递归的判断。

```C++
class Solution {
public:
    //存放分割的回文字符串
    vector<string> path;
    //存放结果
    vector<vector<string>> res;
    void backtracking(const string& str, int index){
        //终止条件,如果起点index 已经到终点了
        if(index == str.size()){
            //放到结果里
            res.push_back(path);
            return;
        }

        //循环，判断是否是回文
        for(int i = index; i < str.size(); ++i){
            //如果是回文串，就放入到路径中
            if(palindromeString(str, index, i)){
                path.push_back(str.substr(index, i - index + 1));
                backtracking(str, i + 1);
                path.pop_back();
            }
        }
    }

    vector<vector<string>> partition(string s) {
        //如果是空，就返回空
        if(s.size() < 1)
            return vector<vector<string>>{};

        backtracking(s, 0);
        return res;
    }

    bool palindromeString(const string& str, int start, int end){
        //如果左边大于右边，错误的参数
        if(start > end)
            return false;

        while(start < end){
            if(str[start] != str[end])
                return false;

            start++;
            end--;    
        }
        return true;
    }
};
```

### [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

思路：

第一眼想的是像之前一样，分割出来，存到新的数组中。但是不如直接在原字符串上进行改动

终止条件不是说到了末尾，而是当 . 的数量已经插入三个之后，直接进行判断，后面的符合条件就放进去，不符合就return

在处理的过程中也需要注意，insert 就是在当前位置插入，而不是当前位置前面插入。注意 erase 的用法。

判断是否有非法字符，是否属于 0-255 区间

```C++
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        //如果存在其他字符串，直接返回
        for(int i = 0; i < s.size(); ++i){
            if(s[i] - '0' > 9)
                return vector<string>{};
        }
        res.clear();
        backtracking(s, 0);
        return res;
    }


private:
    vector<string> res;
    int numDot = 3;
    void backtracking(string& str, int startIndex){
        //终止条件
        if(numDot == 0){
            if(isIP(str, startIndex, str.size() - 1))
                res.push_back(str);
            return;
        }

        //循环判断，是否可行
        for(int i = startIndex; i < str.size(); ++i){
            //如果是属于 0-255，说明可以
            if(isIP(str, startIndex, i)){
                //放入到数组中
                str.insert(str.begin() + i + 1, '.');
                numDot--;
                backtracking(str, i + 2);
                numDot++;
                str.erase(str.begin() + i + 1);
            }
        }
    }
    
    //判断是否属于 0-255
    bool isIP(const string& str, int start, int end){
        if(start > end)
            return false;
        
        //如果第一个是 0 ，并且不止一个数，那就是错的
        if(end - start > 0 && str[start] == '0')
            return false;

        long num = stol(str.substr(start, end - start + 1));
        if(num >= 0 && num <= 255)
            return true;

        return false;
    }
};
```



## 子集

### [78. 子集](https://leetcode.cn/problems/subsets/)

思路：



## 棋盘问题



## 其他

