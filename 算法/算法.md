# 算法

# 数组

## 二分法的思想

整体思路：看见排序的数组（或者自行排序），可以考虑到使用二分法

### [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

思路：

在有序数组中寻找指定元素，显然使用二分法。主要是在于区间的选取方式，是左闭右开 还是 左闭右闭。然后使用while循环进行查找

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int n=nums.size();
        return BinaryFind(nums,0,n-1,target);
    }

    //二分查找
    int BinaryFind(vector<int>& nums,int left,int right,int target)
    {
        //如果没有找到，那么返回-1
        if(left > right)
            return -1;
        else 
        {
            int mid = (left + right)/2;
            if(nums[mid] == target)
                return mid;
            else if(nums[mid] > target)
                return BinaryFind(nums,left,mid-1,target);
            else
                return BinaryFind(nums,mid+1,right,target);            
        }

    }
};
```



## 双指针

使用两个指针进行操作，包括快慢指针，头尾指针等

### [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

思路：

使用双指针（快慢指针）的思想，慢指针的值等于快指针的值，但是只有当快指针不是目标元素时才进行赋值，否则继续向后移动

```C++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowindex = 0;
        int n = nums.size();
        //快指针不断遍历，当是目标元素时，不进行赋值，只有不是目标元素时，才进行赋值
        for(int fastindex = 0;fastindex < n;fastindex++)
        {
            if(nums[fastindex] != val)
                nums[slowindex++] = nums[fastindex];
        }
        return slowindex;
    }
};
```



### [977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

思路：

双指针，因为是非递减顺序，所以前面可以是负数，并且可以两个连续的数相同。 但是平方过后，负数的平方可能比较大。但是平方过后的最大值一定在原数组的最左或者最右边。所以两边都有指针，取最大的放到新数组的最后面。

```C++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> res(nums.size(), 0);
        int left = 0;
        int right = nums.size() - 1;
        int cur = nums.size() - 1;
        while(left <= right){
            long int letf_square = nums[left] * nums[left];
            long int right_square = nums[right] * nums[right];
            if(letf_square > right_square){
                res[cur--] = letf_square;
                left++;
            }
            else{
                res[cur--] = right_square;
                right--;
            }         
        }
        return res;
    }
};
```
### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

思路：

滑动窗口法 。让一个“窗口”一直向前移动，保证里面的序列和是符合条件的，小的话快指针就向后移动，大的话慢指针向后移动。

```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res = INT32_MAX;
        int sublength = 0;
        //定义慢指针
        int slow = 0;
        //定义sum 表示序列的和
        int sum = 0;
        for(int fast = 0;fast < nums.size();++fast)
        {
            //将当前位置的数加上去
            sum += nums[fast];

            //如果当前的和过大，那么就移动左边的窗口
            while(sum >= target)
            {
                sublength = (fast - slow +1);
                res = res < sublength ? res : sublength;
                sum -= nums[slow++];
            }
        }
        //如果res没有被赋值的话，那么就返回0
        return res == INT32_MAX ? 0 : res;
    }
};
```

### [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

思路：

同时处理两个链表，很容易想到使用双指针进行处理

构建新的链表，这里创建一个**虚拟头结点**更加方便

从前向后遍历，即使两个链表有一个到达终点，仍然需要继续加，因为有进位的存在

创建一个进位，以及两个数，如果不空，两个数就是节点的值，如果是空，相应的值就是0，同时不会更新下一步

遍历结束后，还需要判断是否有进位，有的话，还要增加一个节点

```C++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        //创建头结点
        ListNode* dummyHead = new ListNode(0);
        ListNode* cur = dummyHead;
        //用一个数表示进位
        int digit = 0;
        //当两个指针有一个不是空，就要进行运算
        while(l1 != NULL || l2 != NULL){
            //获得需要相加的两个数
            int top = 0, down = 0;
            //如果存在某个是空的，那么就让加的数为0，同时不向后更新
            if(l1 == NULL)
                top = 0;
            else{
                top = l1->val;
                l1 = l1->next;
            }

            if(l2 == NULL)
                down = 0;
            else{
                down = l2->val;
                l2 = l2->next;
            }

            ListNode* s = new ListNode(0);
            int sum = top + down + digit;
            //当前节点的值就是 对10取余
            s->val = sum%10;
            //进位就是 对除以10取整
            digit = sum/10;
    
            cur->next = s;
            cur = cur->next;
        }
        //如果更新完了还有进位，就再增加一个节点
        if(digit > 0){
            cur->next = new ListNode(digit);
        }
        return dummyHead->next;
    }
};
```

### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

思路：

这题是**双指针的滑动窗口**，同时还需要一个容器记录之前出现过的字符

很容易看出是个双指针的题目，问题是在于**怎么处理，以及容器的类型**

- 如果之前**没出现**过，那必然是**加入**到容器中
- 如果**出现过**呢，那就需要左边的指针**向右收缩**，一直到找不到重复的为止，同时还要删除中间的所有字符

res 要一直的比较

```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size() == 0)   return 0;
        //滑动窗口的思想，需要有个容器查找是否出现过
        unordered_set<char> u_set;
        //定义一个开始位置
        int start = 0;
        int res = 0;

        for(int end = 0; end < s.size(); ++end){
            //如果能找到，需要把左边的位置向里面不停的收缩
            //这里是 每次收缩后重新寻找
            while(u_set.find(s[end]) != u_set.end()){
                //先删除，再收缩
                u_set.erase(s[start]);
                start++;
            }
            //到这里说明，左边的收缩完成，那么就把当前的加入进去
            u_set.insert(s[end]);

            res = max(res, end - start + 1);
        }
        return res;
    }
};
```

### [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

思路：

定义两个指针，分别指向两个数组。定义一个数组，保存到中位数出现之前的数，这里要**多保存一个数，为偶数做准备**

然后就是把数组填满，注意这里的边界判断（太麻烦了）

之后，根据奇偶选择返回的值

注意**奇数的时候，返回的不是倒数第二个数，而是最后一个数**，同时，对于 int 的整除（/）不会有小数点，先把两个数转成 double 

```C++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        double res;
        int m = nums1.size(), n = nums2.size();
        //找到数组的中间位置
        int mid = (m + n)/2;
        //定义的数组，保存到 mid 的后面一个位置
        vector<int> nums(mid+1, 0);
        //定义两个指针遍历两个数组
        int left = 0, right = 0;
        for(int i = 0; i < nums.size(); ++i){
            if(left < m && right < n){
                if(nums1[left] < nums2[right])
                    nums[i] = nums1[left++];
                else
                    nums[i] = nums2[right++];
            }
            else if(left >= m)
                nums[i] = nums2[right++];
            else
                nums[i] = nums1[left++];
        }
        //判断奇偶,奇数就返回最后一个
        if((m+n)%2)
            return (double)nums[mid];
        //偶数就返回最后两个数的平均值
        else{
            double A = nums[mid];
            double B = nums[mid-1];
            return (A+B)/2;
        }                  
    }
};
```

### [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

思路：

面积公式，min(height[left], height[right]) * (right - left)

从两边向里面收缩，不能导致面积最大值丢失（相对于当前状态），只有这样才存在让面积变大的可能性

- 移动短板，那么 min(height[left], height[right]) 有可能变大，即使 (right - left) 变小，面积也有可能变大

- 移动长板，那么 min(height[left], height[right]) 会变小，而 (right - left) 也会变小，面积会变小

木桶效应，改变短板

```C++
/*面积公式，min(height[left], height[right]) * (right - left)*/
class Solution {
public:
    int maxArea(vector<int>& height) {
        //定义两个指针
        int left = 0, right = height.size()-1;
        //保存面积的最大值
        int res = 0;
        //当两个指针不相遇的时候
        while(left < right){
            //计算面积，并且保存
            res = max(res, min(height[left], height[right]) * (right - left));
            //然后向里面移动短板
            height[left] <= height[right] ? left++ : right--;
        }
        return res;
    }
};
```



## 模拟题

根据实际情况去模拟每一个步骤的操作

### [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

思路：

首先将上下左右四条边的赋值看成一轮循环，然后在每一轮循环的时候赋值。

定义圈数和每轮循环的起始位置，以及偏移量等，偏移量初始化为1 是因为在每次循环中，都不会把最后一个位置赋值，而是留给下一个循环去赋值

```C++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0));
        //定义当前的值
        int cur_val = 1;
        //定义圈数
        int loop = n/2;
        //定义起始位置
        int start_i = 0;
        int start_j = 0;

        //定义偏移量, 初始化为1 是因为最后一个位置留给下一次循环去赋值
        int offset = 1;

        while(loop--){
            int i = start_i;
            int j = start_j;
            //从左到右
            for(j = start_j; j < n - offset; ++j){
                res[i][j] = cur_val;
                cur_val++;
            }

            //从上到下
            for(i = start_i; i < n - offset; ++i){
                res[i][j] = cur_val;
                cur_val++;
            }

            //从右到左
            for(; j > start_j; --j){
                res[i][j] = cur_val;
                cur_val++;
            }

            //从下到上
            for(; i > start_i; --i){
                res[i][j] = cur_val;
                cur_val++;
            }
            start_i++;
            start_j++;
            offset += 1;
        }

        if(n%2 != 0){
            res[n/2][n/2] = n*n;
        }
        return res;
    }
};
```

### [7. 整数反转](https://leetcode.cn/problems/reverse-integer/)

思路：

思路比较简单，就是一个整数 res，一个不断的取余，加到整数上，最主要的是判断是否越界

因为 res 要乘以 10，所以需要判断没有乘以 10 之前的状态是否越界

2^31-1 = 214748364**7**,-2^31 = -214748364**8**

```C++
class Solution {
public:
    int reverse(int x) {
        int remainder;
        int res = 0;
        while(x != 0){
            remainder = x%10;
            x /= 10;
            //进行判断，当前的 res*10 是否越界
            if(res > INT_MAX/10 || (res == INT_MAX/10 && remainder > 7))    return 0;
            if(res < INT_MIN/10 || (res == INT_MIN/10 && remainder < -8))   return 0;
            res = res * 10 + remainder;
        }
        return res;
    }
};
```

### [8. 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi/)

思路：

这题真的累死人，没有这么复杂，从头开始模拟就行了，主要是题目的限制条件太多，按照条件一个一个判断

判断字符是不是数字 isdigit(c)

还有这里的判断越界的条件，这里的 int 为 -214748364**8** 会算作越界...

```C++
class Solution {
public:
    int myAtoi(string s) {
        int res = 0;
        int i = 0;
        int sign = 1;
        //首先去除空格
        while(i < s.size() && s[i] == ' ')
            ++i;
        
        //然后判断空格后面是不是符号
        if(s[i] == '-')
            sign = -1;

        if(s[i] == '-' || s[i] == '+')
            ++i;
        
        //如果没有越界，并且是数字字符
        while(i < s.size() && isdigit(s[i])){
            int cur = s[i] - '0';
            //判断是否越界
            if(res > INT_MAX / 10 || (res == INT_MAX / 10 && cur > 7))
                return sign > 0 ? INT_MAX : INT_MIN; 
            res = res * 10 + cur;
            ++i;
        }
        return sign * res;
    }
};
```



# 链表

链表的操作多是使用双指针，即一个 pre 和一个 cur

### [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

思路：

设置虚拟节点可以把头结点当做正常节点一样对待，一样处理

整体思路就是，双指针，前驱结点pre，当前节点 cur，当碰到 cur 的值是要删除的值，就跳过

```C++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* pre = dummyHead;
        ListNode* cur = head;
        while(cur != NULL){
            if(cur->val == val){
                cur = cur->next;
                pre->next = cur;
                continue;
            }
             
            pre = cur;
            cur = cur->next;
        }
        return dummyHead->next;
    }
};
```

### [707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/)

思路：

注意，不要随意使用链表的长度！！！！而且插入时，需要注意到前后的连接！！



### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

思路：

原地反转，使用双指针，保存后一个指针，然后把当前指针指向前面

```C++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head == NULL)
            return NULL;
        ListNode* cur = head;
        ListNode* pre = NULL;
        while(cur->next != NULL){
            ListNode* temp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = temp;
        }
        cur->next = pre;
        return cur;
    }
};
/*********************				双指针递归（函数）法				*****************************/
class Solution {
public:

    //就是写一个函数进行两个节点之间的反转，然后进行递归
    ListNode* reverse(ListNode* pre,ListNode* cur){
        if(cur == NULL) 
            return pre;
        ListNode* temp = cur->next;
        cur->next = pre;
        return reverse(cur,temp);
    }
    
    ListNode* reverseList(ListNode* head) {
        return reverse(NULL,head);
    }
};
```

### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

思路：

刚开始有点懵，实际上也就是双指针

需要虚拟节点方便操作，pre指向交换两节点的前驱结点，cur指向交换的第一个节点

需要判断第二个节点是不是空，在判断next的时候，由于跳了两个，需要判断前一个是否为空

交换第一个节点和第二个节点，再向前移动两个位置

```C++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head == NULL)
            return NULL;
        //虚拟节点方便操作
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        //定义双指针，pre指向交换的两节点的前面一个节点
        ListNode* pre = dummyHead;
        ListNode* cur = head;
        //判断这个节点不是空之后，需要判断第二个交换的节点是否是空，后面就无所谓了
        while(cur != NULL && cur->next != NULL){
            //temp 代表第二个交换的节点
            ListNode* temp = cur->next;
            //交换第一个和第二个节点
            cur->next = temp->next;
            temp->next = cur;
            pre->next = temp;
            //向后移动两个位置
            cur = temp->next->next;
            pre = pre->next->next;
        }
        return dummyHead->next;
    }
};
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

思路：

倒数第几个节点的问题可以转化为，两个指针的距离是 n，而快指针就是尾结点，慢指针就是倒数第 n 个节点

先让快指针走 n 步，再让慢指针走（注意之间的距离与 n 的关系）

```C++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        if(head == NULL)
            return NULL;
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;

        ListNode* slow = dummyHead;
        ListNode* fast = dummyHead;
        //快指针先走
        while(fast->next != NULL && n--){
            fast = fast->next;
        }
        //两个指针同时走，快的到达终点后，删除慢指针的后一个指针
        while(fast->next != NULL){
            slow = slow->next;
            fast = fast->next;
        }

        //删除节点
        ListNode* temp = slow->next;
        slow->next = temp->next;
        delete(temp);
        
        return dummyHead->next;
    }
};
```

### [面试题 02.07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

思路：

整体思路就是相交在同一个节点，那么两个指针的值是相同的（都是该节点的地址），于是需要末尾对齐

首先求出各自的长度，然后让长链表指针后移，距离是长度之间的差值，让它们末尾对齐

然后同时移动，找到两个指针值相同的位置

问：如果是求中间相交的节点呢？

```C++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        //各遍历一遍找到它们之间长度的差值
        int num_A = 0;
        int num_B = 0;

        //获得链表A的长度
        ListNode* cur = headA;
        while(cur != NULL){
            num_A++;
            cur = cur->next;
        }
        //获得链表B的长度
        cur = headB;
        while(cur != NULL){
            num_B++;
            cur = cur->next;
        }

        ListNode* cur_A = headA;
        ListNode* cur_B = headB;
        //获得长度的差值，把它们尾部对齐
        int n = abs(num_A-num_B);
        if(num_A > num_B){
            while(n--){
                cur_A = cur_A->next;
            }
        }
        else{
            while(n--){
                cur_B = cur_B->next;
            }
        }

        //两个指针同时移动
        while(cur_A != NULL && cur_B != NULL){
            if(cur_A == cur_B)
                return cur_A;

            cur_A = cur_A->next;
            cur_B = cur_B->next;
        }
        return NULL;
    }
};
```

### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

思路：

首先快慢指针判断是否有环是显而易见的，但是怎么判断换的入口在哪里呢？？？

 经过数学推论，可以得出一个结论：**当快慢指针相遇时，在头结点和相遇节点同时出发两个指针，每次走一步，那么相遇时就是环的入口**

```C++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        //快慢指针，先确定是否有环
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast != NULL && fast->next != NULL){
            slow = slow->next;
            fast = fast->next->next;

            //如果两者相遇，说明有环
            if(slow == fast){
                //从头结点和相遇节点处开始，每次走一步，相遇时即为环的入口
                ListNode* index1 = head;
                ListNode* index2 = fast;
                while(index1 != index2){
                    index1 = index1->next;
                    index2 = index2->next;
                }
                return index1;
            }
        }
        return NULL;
    }
};
```





# 哈希表

哈希表擅长处理查找，或出现次数等问题

### [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

思路：

就是利用哈希表的思想，把每个字母映射成数字，遍历第一个字符串时出现一次加一次，遍历第二个字符串的时候，出现一次减一次。最后判断是不是全是 0。当然可以使用数组进行映射

```C++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};

        //遍历第一个字符串
        for(int i = 0;i<s.size();++i){
            record[s[i]-'a']++;
        }

        //遍历第二个字符串
        for(int j = 0;j<t.size();++j){
            record[t[j]-'a']--;
        }

        //检查
        for(int i = 0;i<26;++i){
            if(record[i] != 0)
                return false;
        }

        return true;
    }
};
```

### [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

思路：

就是把 nums1 的数放到 unorder_set 里面，再遍历 nums2，如果能在 set 里面找到，那就放到结果中，并从set里面擦除

```C++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> un_set;
        vector<int> res;
        for(int i = 0; i < nums1.size(); ++i)
            un_set.insert(nums1[i]);

        for(int j = 0; j < nums2.size(); ++j){
            auto it = un_set.find(nums2[j]);
            if(it != un_set.end()){
                res.push_back(nums2[j]);
                un_set.erase(nums2[j]);
            }
        }
        return res;
    }
};
```

### [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

思路：

首先给一个数，需要计算各个位置上数的平方和，那么可以写一个函数。并不需要判断这个数是多少位，只需要每次取末尾数的平方加到 sum 上，然后 n 去掉末尾（n /= 10）

无限循环意味着，曾经的和可能会再次出现，这就说明不可能是快乐数

```C++
class Solution {
public:
    //计算和
    long int getsum(int n){
        long int sum = 0;
        while(n){
            sum += (n%10) * (n%10);
            n /= 10;
        }
        return sum;
    }

    bool isHappy(int n) {
        unordered_set<long int> res;
        while(getsum(n) != 1){
            if(res.find(getsum(n)) != res.end()){
                return false;
            }
            else {
                res.insert(getsum(n));
                n = getsum(n);
            }
        }
        return true;

    }
};
```

### [1636. 按照频率将数组升序排序](https://leetcode.cn/problems/sort-array-by-increasing-frequency/)

思路：

使用一个 map 容器保存数字以及出现的次数，然后按照其出现的次数排序

这里的 **map 容器不能使用 sort 函数进行排序**，因此需要把 map 的数据放到 vector 数组中

然后定义排序规则，按照第二个数（出现的次数）排序

再定义一个 vector 数组，存放结果

```C++
class Solution {
public:
    static bool Mycompre(const pair<int, int>& u1, const pair<int, int>& u2){
        if(u1.second == u2.second)  return  u1.first > u2.first;
        return u1.second < u2.second;
    }
    vector<int> frequencySort(vector<int>& nums) {
        unordered_map<int, int> u_map(nums.size());
        
        for(int i = 0; i < nums.size(); ++i){
            if(u_map.find(nums[i]) == u_map.end())
                u_map.insert({nums[i], 1});
            else
                u_map[nums[i]] ++;
        }
        vector<pair<int, int>> vec(u_map.begin(), u_map.end());

        sort(vec.begin(), vec.end(), Mycompre);
        vector<int> res;
        for(auto it = vec.begin(); it != vec.end(); ++it){
            while(it->second > 0){
                res.push_back(it->first);
                it->second--;
            }       
        }
        return res;
    }
};
```





## 几数之和

此类题目通常从 两数之和开始，到三数之和，四数之和

对于几数之和来说，如果求的是元素值而不是下标，那么就可以使用双指针的方法在原本的复杂度上降低一个数量级。比如三数之和的O（n3）变成O（n2）

**双指针：** 需要先排序（为了去重和双指针的移动），留下两个指针左右移动，剩下的使用for循环当做固定的。判断这些和与目标值的关系来移动左右指针，注意在相等放入结果容器之后，需要移动两边的指针，同时注意去重

不使用哈希表的原因就是去重比较麻烦

### [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

思路：

map可以保存 值和下标，无序容器更加快，省去了排序的时间

从头开始遍历，看另外一个数是不是在 map 里，如果找到，则返回。否则将这个数和下标插入到 map 里。

```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> un_map;
        for(int i = 0; i < nums.size(); ++i){
            if(un_map.find(target-nums[i]) != un_map.end()){
                return vector<int>{un_map.find(target-nums[i])->second, i};
            }
            else
                un_map.insert({nums[i], i});
        }
        return vector<int>{0, 0};
    }
};
```

### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

思路：

**哈希法**：两重循环判断，固定第一个数的位置，内循环的时候，如果能找到剩下的值，就放到结果里，并且把 set 容器里的 b 删除，这样相当于对 c 去重，找不到就放入 set 中当 b

**双指针法**：首先进行排序，以便移动指针。然后固定一个 i 表示以 i 开头的三元组。left = i + 1，right 在末尾的位置，当三个位置的和相加**大于 0** 时，将 right 向左移动，**小于0**时，left向右移动。当**等于0**时，放到结果里，这时候，需要两边需要移动，如果只移动一个，另一个不不动，那么结果仍然会重复。在移动的过程中注意重复。

注意：需要判断 i 是否会重复，i > 0 && nums[i] != nums[i-1]

思考：两数之和为什么不用双指针？因为返回的是下标，不能排序！！！



```C++
/****************************************    哈希表（要去重）		***************************************/
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;

        for(int i = 0; i < nums.size(); ++i){
            // a 去重
            if(i > 0 && nums[i] == nums[i-1])
                continue;
            unordered_set<int> un_set;
            for(int j = i+1; j < nums.size(); ++j){
                // 去重 b，这个地方不明白
                if(j > i+2 && nums[j] == nums[j-1] && nums[j-1] == nums[j-2])
                    continue;
                auto it = un_set.find(0-nums[i]-nums[j]);
                if(it != un_set.end()){
                    res.push_back({nums[i], *it, nums[j]});
                    // 去重 c,因为删除容器里的b之后，不会再出现 nums[j] = c 了
                    un_set.erase(0-nums[i]-nums[j]);
                }     
                else
                    un_set.insert(nums[j]);
            }
        }
        return res;
    }
};
/****************************************    三指针	***************************************/
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        for(int i = 0; i < nums.size(); ++i){
            if(i > 0 && nums[i] == nums[i-1])
                continue;

            int left = i + 1; 
            int right = nums.size()-1;
            
            while(left < right){
                int sum = nums[i] + nums[left] + nums[right];
                if(sum == 0){
                    res.push_back({nums[i], nums[left], nums[right]});
                    //两边同时收缩，因为只收缩一边，另外一个值仍然是重复值
                    //收缩的时候，需要去重
                    while(left < right && nums[left+1] == nums[left])
                        left++;
                    while(left < right && nums[right] == nums[right-1])
                        right--;

                    left++;
                    right--;
                }          
                else if(sum < 0)
                    left++;
                else
                    right--;
            }
        }
        return res;
    }
};
```

### [18. 四数之和](https://leetcode-cn.com/problems/4sum/)

思路：

**双指针法**：类似三数之和，本题需要的是四个指针，那四个指针如何移动判断呢？

固定两个指针 i ，j 剩下两个进行大小的移动，即需要两重循环

仍然是需要判定重复，需要注意的是，j 指针的重复怎么判断，简单的让 nums[j] == nums[j-1]并不行，如果 j == i 的时候，就会误判，所以需要让 j > i +1 && nums[j] == nums[j-1] 的时候这个时候才是 j 的重复判定

溢出问题需要注意，四个数相加太大，那么移到右边变成减法

```C++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> res;
        //先排序
        sort(nums.begin(),nums.end());

        //两重循环，固定前面两个数
        for(int i = 0; i < nums.size();++i){
            //去重
            if(i > 0 && nums[i] == nums[i-1])
                continue;
            //固定第二个数
            for(int j = i + 1; j< nums.size();++j){
                if(j > i + 1 && nums[j] == nums[j-1])
                    continue;
                
                int left = j + 1;
                int right = nums.size()-1;

                while(left < right){
                    //不用 (nums[i] + nums[j] + nums[left] + nums[right]) > target 是因为会溢出
                    if(nums[i] + nums[j] > target - nums[left] - nums[right]){
                        --right;
                    }
                    else if(nums[i] + nums[j] < target - nums[left] - nums[right]){
                        ++left;
                    }
                    else{
                        res.push_back(vector<int>{nums[i],nums[j],nums[left],nums[right]});
                        while(left < right && nums[left] == nums[left+1])
                            ++left;
                        while(left < right && nums[right] == nums[right-1])
                            --right;
                        ++left;
                        --right;
                    }
                }
            }
        }
        return res;
    }
};
```

### [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)

思路：

一开始打算利用三重循环加上 hash 计算，但是三重循环的时间复杂度太高了，O（n3）,主要是hash 法用的不对。

**哈希法**：首先二重循环遍历前两个数组，两两相加，使用 map 记录两数和出现的次数。

再用二重循环遍历后两个数组，在 map 中查找是否存在 0-(c+d) 的，如果存在，获得出现的次数，加到 count 上，时间复杂度O(n2)

为什么可以用哈希法，而不是指针法？？因为不是在一个数组里面找，不能排序，而且不需要去重！！！

```C++
class Solution {
public:
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
        int count = 0;
        //定义一个map来保存，前两个数组两两相加的结果
        unordered_map<int,int> temp_map;

        //前两个数组两两相加，记录所有和出现的次数
        for(int a : nums1){
            for(int b : nums2){
                temp_map[a+b]++;
            }
        }

        //遍历后两个数组，然后找到 0 - (c+d)
        for(int c : nums3){
            for(int d : nums4){
                auto it = temp_map.find(0 - (c+d));
                if(it != temp_map.end()){
                    //count 加上 所有符合条件的个数
                    count += it->second;
                }
            }
        }
        return count;

    }
};
```

# 字符串

## 双指针

利用双指针的方法，处理字符串，通常处理字符串的反转，快慢指针的赋值

### [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

思路：

原地逆转，不能使用额外的空间，使用双指针，从两端向中间移动。移动过程中进行 字符的交换

```C++
class Solution {
public:
    void reverseString(vector<char>& s) {
        //双指针？
        int left = 0;
        int right = s.size()-1;
        while(left < right){
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;

            ++left;
            --right;
        }
    }
};
```

### [541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)

思路：

一开始有点不太明白，但其实模拟一下会发现，每次都是从0、2K、4K处开始反转，然后向后反转K个字符。所以 i += 2K。

另外一开始觉得 i 的范围，用了复杂的表达式来计算，但是不管怎么说，肯定是小于 s.size() 的。

可以另外写一个反转函数，来反转传入的字符串 起始位置后的K个字符。

```C++
class Solution {
public:
    //写一个函数用来反转 a 开始后 k 个字符串
    void reverse(string& s,int a,int k){
        int left = a;
        int right = a + (k-1);
        if(right > s.size()-1)
            right = s.size()-1;
        while(left < right){
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            ++left;
            --right;
        }
    }

    string reverseStr(string s, int k) {
        //遍历字符串，每次在 0，2K，4K处开始向后反转 k 个字符串
        for(int i = 0; i < s.size(); i += 2*k){
            reverse(s,i,k);
        }
        return s;
    }
};
```

### [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

思路：

第一眼看，感觉就是直接遍历找到空格，然后替换“%20”，但是发现这是三个字符，而空格只能替换一个字符，因此需要把后面的字符向

后移动，但是太过麻烦。

**法一：另外创建一个字符串** 然后将原字符串的字符一个个移动过去，碰到空格，再进行处理

**法二：原地修改** 原地修改的方法首先统计出字符串中空格的个数，然后将字符串扩容，这时候空间足够了（后面的空的）。

在原地使用双指针进行复制，从前面依然会需要移动后面的字符，所以需要从后面进行操作。

**其实很多数组填充类的问题，都可以先预先给数组扩容到填充后的大小，然后再从后向前进行操作。**

```C++
/******************* 另外一个字符串 ***********************/
class Solution {
public:
    string replaceSpace(string s) {
        string str;
        for(int i = 0; i<s.size();++i){
            if(s[i] == ' '){
                str += "%20";
            }
            else{
                str += s[i];
            }
        }
        return str;
    }
};
/******************* 原地修改 ***********************/
class Solution {
public:
    string replaceSpace(string s) {
        //首先遍历一遍，得出空格的个数，然后进行扩容
        int count = 0;
        int sOldsize = s.size();
        for(int i = 0;i<s.size();++i){
            if(s[i] == ' ')
                ++count;
        }

        //扩容
        s.resize(s.size() + (count * 2));
        int sNewsize = s.size();

        //从后向前遍历
        for(int j = sNewsize - 1,k = sOldsize - 1; j > 0 ;){
            if(s[k--] == ' '){
                s[j--] = '0';
                s[j--] = '2';
                s[j--] = '%';
            }
            else{
                s[j--] = s[k];
            }
        }
    }
};
```

### [151. 颠倒字符串中的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

思路：

一开始有点麻烦，反转还好，主要是在处理反转的同时还要处理空格，这样代码就会变的非常复杂，而且思路也容易乱。

那么可以考虑先把多余的空格去掉，然后再进行反转就会方便一点。

写去除空格的函数也有点麻烦，可以参考[去除数组中指定的元素](https://leetcode-cn.com/problems/remove-element/)的方法，同样是原地去除指定的空格，使用双指针法。**也即数组的第二题**

可以分成三种情况进行处理，前面的、中间的、末尾的空格。判断条件需要想一想。

去除空格之后，将每个单词反转，并且最后整体反转一次。

```C++
class Solution {
public:
    //定义一个反转函数，用来反转
    void reverse(string& s,int left,int right){
        if(right > s.size()-1)
            right = s.size()-1;

        while(left < right){
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            //移动
            ++left;
            --right;
        }
    }

    //去除多余的空格
    void removeSpace(string& s){
        //双指针
        int slowindex = 0,fastindex = 0;
        //去掉前面的空格
        while(s[fastindex] == ' '){
            fastindex++;
        }

        //去掉中间的空格，把空格当成正常复制，多的不能复制
        for(;fastindex < s.size();++fastindex){
            if(s[fastindex] == ' ' && s[fastindex-1] == ' ')
                continue;
            else
                s[slowindex++] = s[fastindex];
        }

        //去掉末尾的空格,注意此时 slowindex已经在后面一个位置了
        //并且 resize 的参数是 元素的个数！！！最后一个元素的后一位
        if(s[slowindex - 1] == ' ')
            s.resize(slowindex-1);
        else
            s.resize(slowindex);
    }

    string reverseWords(string s) {
        //首先去除空格
        removeSpace(s);

        //定义初始位置和结束位置
        int start = 0,end = 0;
        //循环遍历
        for(int i = 0;i < s.size();++i){
            if(s[i] == ' '){
                end = i - 1;
                reverse(s,start,end);
                start = i + 1;
            }

        }
        //最后一个单词没有空格，单独进行反转
        reverse(s,start,s.size()-1);
        //将整个句子全部反转
        reverse(s,0,s.size()-1);
        return s;
    }
};
```

### [剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

思路：

老朋友了这题，先反转前面的，再反转后面的，最后全部反转

局部反转+整体反转

```C++
class Solution {
public:
    //首先定义反转函数
    void reverse(string& s,int start,int end){
        while(start < end){
            swap(s[start],s[end]);
            ++start;
            --end;
        }
    }

    string reverseLeftWords(string s, int n) {
        //前面反转
        reverse(s,0,n-1);
        //后面反转
        reverse(s,n,s.size()-1);
        //全部反转
        reverse(s,0,s.size()-1);
        return s;
    }
};
```

## KMP

主要思想就是当碰到两个指针所指位置的字母不同时，需要看前面一个的 next 数组，回退到前面的位置

- 首先求出长数组的next数组，求next数组的过程看做是匹配的过程

- 然后根据next数组进行匹配

### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

思路：

KMP

```c++
class Solution {
public:
    //构造next数组函数
    void getnext(const string& s, vector<int>& next){
        next[0] = -1;
        //可以把求 next 数组的过程也看成 字符串的匹配过程，i 主串，j 就是模式串
        //需要先判断不相等的情况，如果先判断相等的情况，否则j++了，但是 i 并没有++
        //此时再判断它们不相等的情况就会出现问题
        for(int i = 1,j = -1; i < s.size(); ++i){
            //如果s[i] 和 s[j+1]不相等的话，j 就需要移动，看前面一个位置(j)的next数组
            // j = next[j], 然后继续看 j+1 是否和 i 相等
            // j >= 0 是保证数组是有意义的
            while(j >= 0 && s[i] != s[j+1]){
                j = next[j];
            }

            //如果相等，那就向后移动
            if(s[i] == s[j+1]){
                ++j;
            }
            next[i] = j;
        }
    }
    int strStr(string haystack, string needle) {
        //如果 haystack 是空，直接返回0
        if(haystack.size() == 0)
            return 0;
        //如果 needle 长度比 haystack 长，直接返回
        if(needle.size() > haystack.size())
            return -1;
        vector<int> next(haystack.size());
        //获得next数组
        getnext(needle, next);
        
        for(int i = 0, j = -1; i < haystack.size(); ++i){
            while(j >= 0 && haystack[i] != needle[j+1]){
                j = next[j];
            }

            if(haystack[i] == needle[j+1]){
                ++j;
            }
            
            if(j == (needle.size()-1))
                return (i-j);
        }                       
        return -1;         
    }
};
```

### [459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)

思路：

KMP

```C++
class Solution {
public:
    //构建next 数组
    void getNext(const string& s,int* next){
        int j = -1;
        next[0] = j;
        for(int i = 1;i<s.size();++i){
            //可以把求 next 数组的过程也看成 字符串的匹配过程，i 主串，j 就是模式串
            //当i 所指的和 j+1 不一样时，这时就看前一个位置的 next[j],用来回退
            //回退的过程中，因为 要保证数组不能越界，所以 j >= 0
            while( j >= 0 && (s[i] != s[j+1])){
                j = next[j];
            }
            //如果 i 所指的和 j+1 是一样的话，那么就 j 就向后移动
            if(s[i] == s[j+1]){
                ++j;
            }
            //将 后缀匹配的 前缀长度 记录到 next 数组
            next[i] = j;
        }
    }
    bool repeatedSubstringPattern(string s) {
        int next[s.size()];
        getNext(s,next);

        //如果公共前后缀是 长度的 整数倍，那就是由重复子串构成
        int len = s.size();
        if(next[len-1] != -1 && len%(len - (next[len-1] + 1)) == 0)
            return true;
        
        return false;
    }
};
```



# 栈和队列

### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

思路：

两个栈实现一个队列，就是先放进一个栈A中，在把A中的数据放到B中，此时B的出栈顺序就是队列的顺序

注意到只有当栈 B 中没有数据时，才从栈 A 中转移数据到 栈B。同时先处理是空的情况，这样后面处理不是空的情况就可以一起处理

```C++
class MyQueue {
public:
    //创建两个栈
    stack<int> stA;
    stack<int> stB;
    MyQueue() {
        
    }
    
    void push(int x) {
        stA.push(x);
    }
    
    int pop() {
        //如果第二个栈中没有数据才把第一个栈的数据转移
        //先处理是空的情况，这样后面处理不是空的情况就可以一起处理
        if(stB.empty()){
            while(!stA.empty()){
                stB.push(stA.top());
                stA.pop();
            }
        }
        //此时说明栈中有数据（可能是之前的，也可能是新转移的）
        int res = stB.top();
        stB.pop();
        return res;
    }
    
    int peek() {
        //复用 pop（）
        int res = this->pop();
        // 把pop()出的结果放回来，然后返回
        stB.push(res);
        return res;
    }
    
    bool empty() {
        if(stA.empty() && stB.empty())
            return true;
        else
            return false;
    }
};
```

### [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

思路：

用队列实现栈，两个队列的用法和 用队列实现栈不一样

两个队列 Q1、Q2，元素都放到Q1里面，当需要 pop 时，将Q1的元素，除了最后一个，全部都移动到Q2，然后将Q1的最后一个元素 pop（）。再把Q2里面的元素全部移动到 Q1。

一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了。

> queue 单向队列、deque 双向队列

```C++
class MyStack {
public:
    queue<int> Q1;
    queue<int> Q2;

    MyStack() {

    }
    
    void push(int x) {
        Q1.push(x);
        
    }
    
    int pop() {
        //先把最后一个前面的移到 Q2，然后在移动到Q1
        while(Q1.size() != 1){
            Q2.push(Q1.front());
            Q1.pop();
        }
        int res = Q1.front();
        Q1.pop();

        while(!Q2.empty()){
            Q1.push(Q2.front());
            Q2.pop();
        }
        return res;
    }
    
    int top() {
        return Q1.back();
    }
    
    bool empty() {
        if(Q1.empty())
            return true;
        else
            return false;
    }
};
```

### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

思路：

如果是左括号就入栈，然后是右括号在一个一个判断是不是相应的左括号，那这样就慢了

如果是左括号，就入栈相应的右括号，那么后续判断的时候，就不需要对应了，只需要判断栈顶元素和 s[i] 的值是否相等就行了

最后返回的时候，返回栈是否是空，恰好出栈完就是对的

```C++
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        //只要是左括号就入栈相应的右括号，后续只需要判断栈顶和 s[i] 是否相等就行了
        for(int i = 0; i < s.size(); ++i){
            if(s[i] == '(')         st.push(')');
            else if(s[i] == '{')    st.push('}');
            else if(s[i] == '[')    st.push(']');
            else if(!st.empty() && s[i] == st.top())   st.pop();
            else    return false;
        }
        
        //直接返回是否是空就行了，是空就是true
        return st.empty();
    }
};
```

### [1047. 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)

思路：

和括号匹配一样的思路，利用栈来进行相同字符的消除，出栈之后反转一下。

```C++
class Solution {
public:
    string removeDuplicates(string s) {
        stack<char> st;
        for(int i = 0; i < s.size(); ++i){
            if(!st.empty() && s[i] == st.top())
                st.pop();
            else
                st.push(s[i]);
        }
        string str;
        while(!st.empty()){
            str += st.top();
            //str.push_back(st.top());
            st.pop();
        }
        //算法自带的反转函数
        reverse(str.begin(), str.end());
        return str;
    }
};
```

### [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)

思路：

主要就是将 字符串转成数字放入到栈中，使用 stoi（）函数。

碰到运算符的时候，取出后面两个数（注意哪个是 num1 和 num2），然后根据运算符运算

```C++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<int> st;
        //遍历每个元素，如果是运算符，进行运算，否则放到栈中
        for(int i = 0; i < tokens.size(); ++i){
            if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/"){
                //获得两个操作数
                int num2 = st.top();
                st.pop();
                int num1 = st.top();
                st.pop();
                //根据符号进行四则运算
                if(tokens[i] == "+")    st.push(num1 + num2);
                else if(tokens[i] == "-")   st.push(num1 - num2);
                else if(tokens[i] == "*")   st.push(num1 * num2);
                else    st.push(num1 / num2);
            }
            else
                st.push(stoi(tokens[i]));
        }
        return st.top();
    }
};
```

### [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

思路：

使用队列来当做滑动窗口，但是如何返回队列里面的最大值呢？

因此定义一个单调队列，让队列里面的元素是有序的，从大到小排列，那么**队头元素就是队列里面的最大值**，直接获得即可

需要自己定义单调队列，常用的功能有哪些需要自己设计？获取队头元素front、插入元素push、删除元素pop

> front()：直接返回队头元素即可
>
> push()：因为需要保证队列是有序的，那么插入时候需要判断队尾元素是否比该元素小，若队尾小，则出队，直到找到大于等于它的元素
>
> pop()：这个也需要设计是当出队的元素是队头元素，说明此时滑动窗口已经要放弃这个元素了，要出队，否则不出队

对于整个数组的遍历需要先把前 K 个元素放到滑动窗口中，找出最大的

然后在后续的遍历中，依照 先出队，然后进队，选出最大 这种顺序，依次遍历

```C++
class Solution {
public:
    class Myqueue{
    public:
        deque<int> _Q;
        int front(){
            return _Q.front();
        }
        //保证队列中的元素是从大到小排列的，
        //当遇到一个元素时，先判断队尾元素和它的大小，若队尾元素小，队尾直接出队，直到队尾元素比它大
        void push(int x){
            while(!_Q.empty() && _Q.back() < x){
                _Q.pop_back();
            }
            _Q.push_back(x);
        }
        
        //出元素的时候判断,是否是队头元素，不是就不出队列
        void pop(int x){
            if(!_Q.empty() && _Q.front() == x)
                _Q.pop_front();
        }
    };
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        Myqueue Q;
        vector<int> res;

        //先把前K个放进去，并且找到最大的
        for(int i = 0; i < k; ++i)
            Q.push(nums[i]);
        res.push_back(Q.front());
        //遍历，每一次进入一个元素，同时出一个元素，保持平衡
        for(int j = k; j < nums.size(); ++j){
            //出队一个
            Q.pop(nums[j-k]);
            //入队一个
            Q.push(nums[j]);
            //返回队头元素
            res.push_back(Q.front());
        }
        return res;
    }
};
```

### [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

思路：

首先需要使用map统计每个元素出现的次数，如何根据map的value进行排序？

因为map的数据可以当成pair，放入到vecor中，再根据自定义的排序仿函数进行排序，根据出现的次数从大到小排列

也可以使用优先队列，C++有优先队列这种东西，其内部实现就是堆，可以自行选择大根堆或者小根堆。

然后就是选择小根堆！！！而不是大根堆。因为小根堆可以保证堆顶下面的数，一定都比堆顶大，最后的K个数就是最大的前K个数。如果是大根堆，堆顶是最大的，而下面的都比较小。

- 其次就是优先队列的创建，<元素类型，放置元素的容器，定义的排序仿函数>

```C++
/**************************************    根据map转为vec排序		*********************************/
class Solution {
public:
    //自定义的排序规则
    class Mycompare{
    public:
        bool operator() (const pair<int, int> lhs, const pair<int, int> rhs) {
            return lhs.second > rhs.second;
        }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        //首先遍历，使用map保存每个数字出现的次数
        unordered_map<int, int> un_map;
        for(int i = 0; i < nums.size(); ++i){
            un_map[nums[i]]++;
        }

        //然后把map的key、value组成 pair 放入到vector中
        vector<pair<int, int>> vec(un_map.begin(), un_map.end());
        //vector 根据自定义的规则，对出现的次数从小到大进行排列
        sort(vec.begin(), vec.end(), Mycompare());
        
        vector<int> res;
        //取前K个高频的数字
        for(int i = 0; i < k; ++i){
            res.push_back(vec[i].first);
        }
        return res;
    }
};
/***********************************		优先队列		***********************************/
class Solution {
public:
    //仿函数，用来建立小根堆
    class Mycompare{
    public:
        bool operator()(const pair<int,int>& map1,const pair<int,int>& map2){
            return map1.second > map2.second;
        }
    };

    vector<int> topKFrequent(vector<int>& nums, int k) {
        //定义一个 map 保存数出现的频率
        unordered_map<int,int> temp_map;
        vector<int> res(k);
        for(int num : nums){
            temp_map[num]++;
        }

        //根据频率排序，建立优先级队列
        priority_queue<pair<int,int>,vector<pair<int,int>>,Mycompare> priq;

        //遍历map，把里面的键值对放入到队列中，选择前K个
        for(unordered_map<int,int>::iterator it = temp_map.begin();it!=temp_map.end();++it){
            priq.push(*it);
            if(priq.size() > k){
                priq.pop();
            }
        }

        //最后根据出现频率输出
        for(int i = 1; i <= k; ++i){
            res[k-i] = priq.top().first;
            priq.pop();
        }
        return res;
    }
};
```

# 二叉树

1、带有返回值的函数，可以不用接收返回值！！！

2、注意区分高度和深度的概念，高度是从该节点到叶子结点，深度是从根节点到该节点。求深度是从上到下遍历，使用前序遍历。而求高度则是从下往上，使用后序遍历。

3、递归的时候，如果判断了该节点是否为空，那么下面可以直接传入。否则，在下面递归传入的时候，需要判断节点不为空才能传

### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

思路：

经典的前序遍历，递归法的**返回值**是什么，**参数**是什么，**终止条件**是什么，**处理逻辑**是什么

迭代法需要使用栈辅助，先把根节点入栈（如果不是空的情况下），然后while循环里的处理逻辑，取出栈顶元素处理，然后把右孩子，左孩子依次入栈。右孩子先近栈，后出栈

```C++
/*****************************   递归法    *********************************/
class Solution {
public:
    vector<int> res;
    //定义前序遍历的递归函数
    void pretraversal(TreeNode* root){
        //终止条件
        if(root == NULL)
            return;
        //处理 中 的节点
        res.push_back(root->val);
        //遍历左孩子
        pretraversal(root->left);
        //遍历右孩子
        pretraversal(root->right);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        pretraversal(root);
        return res;
    }
};
/******************************     迭代法      ********************************/
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        //如果树是空的
        if(root == NULL)
            return vector<int>{};
        vector<int> res;
        //迭代法需要使用栈来辅助
        stack<TreeNode*> st;
        //把根节点入栈
        st.push(root);
        //循环取得栈中的节点
        while(!st.empty()){
            //取出栈顶结点
            TreeNode* node = st.top();
            st.pop();

            //处理 中 节点
            res.push_back(node->val);
            //如果有右孩子，把右孩子进栈
            if(node->right != NULL)
                st.push(node->right);
            //如果有左孩子，把左孩子进栈
            if(node->left != NULL)
                st.push(node->left);
        }
        return res;
    }
};
```

### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

思路：

后序遍历的迭代法有点东西，其顺序是 左、右、中，其实就是 中、右、左反过来，那么其实就和前序遍历的方法一样，最后结果数组反转一下就行

```C++
/*************************        递归法       ************************/
class Solution {
public:
    vector<int> res;
    void postTraversal(TreeNode* root){
        //终止条件
        if(root == NULL)
            return;
        //左
        postTraversal(root->left);
        //右
        postTraversal(root->right);
        //中
        res.push_back(root->val);
    }
    vector<int> postorderTraversal(TreeNode* root) {
        postTraversal(root);
        return res;
    }
}; 
/***********************        迭代法          ***********************/
class Solution {
public:
    //前序遍历：中，左，右      后序遍历：左，右，中，其实就是中右左反过来
    vector<int> postorderTraversal(TreeNode* root) {
        //如果树是空
        if(root == NULL)
            return vector<int>{};
        vector<int> res;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()){
            //获得栈顶元素，并出栈
            TreeNode* node = st.top();
            st.pop();

            //处理中
            res.push_back(node->val);
            //左入栈
            if(node->left)
                st.push(node->left);
            //右入栈
            if(node->right)
                st.push(node->right);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

思路：

迭代法不仅需要栈辅助，还需要一个全局指针辅助

先向左下角找，如果节点不是空，那么就入栈，并且指向左孩子，直到左孩子为空

此时栈顶元素就是中节点，相当于左节点就是空了，然后取出栈顶元素进行处理，然后让指针指向该节点的右孩子

```C++
/******************        递归        ***********************/
class Solution {
public:
    vector<int> res;
    void inTraversal(TreeNode* root){
        if(root == NULL)
            return;
        //左
        inTraversal(root->left);
        //中
        res.push_back(root->val);
        //右
        inTraversal(root->right);
    }
    vector<int> inorderTraversal(TreeNode* root) {
        inTraversal(root);
        return res;
    }
}; 
/******************            迭代        ***********************/
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        
        TreeNode* cur = root;
        //加上 cur != NULL 的条件是因为想让根节点和其他节点一样处理
        //如果根节点先入栈，然后不加条件，那么如果根节点不空，还会进栈一次
        while(cur != NULL || !st.empty()){
            //如果该节点不空，就让该节点进栈，访问左孩子
            if(cur != NULL){
                st.push(cur);
                cur = cur->left;
            }
            else{
                //如果该节点是空，说明没有左孩子，栈顶元素就是中节点
                TreeNode* node = st.top();
                st.pop();
                res.push_back(node->val);
                //让该节点指向右孩子
                cur = node->right;
            }
        }
        return res;
    }
};
```

### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

连打十题

- 102.二叉树的层序遍历
- 107.二叉树的层次遍历II
- 199.二叉树的右视图
- 637.二叉树的层平均值
- 429.N叉树的层序遍历
- 515.在每个树行中找最大值
- 116.填充每个节点的下一个右侧节点指针
- 117.填充每个节点的下一个右侧节点指针II
- 104.二叉树的最大深度
- 111.二叉树的最小深度

思路：

队列辅助，获得每一层的数量，然后依次出队列，同时把下一层的节点入队

```C++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        //如果是空树
        if(root == NULL)
            return vector<vector<int>>{};
        //需要定义队列辅助
        queue<TreeNode*> Q;
        vector<int> temp;
        vector<vector<int>> res;
        //让根节点先进队列
        Q.push(root);

        //总循环
        while(!Q.empty()){
            //获得当前的size
            int size = Q.size();
            //收集之前先清零
            temp.clear();
            //进行每一层的循环,每一层存到temp中
            while(size--){
                //获得队头元素并出队
                TreeNode* node = Q.front();
                Q.pop();

                //处理
                temp.push_back(node->val);
                //左孩子
                if(node->left)
                    Q.push(node->left);
                //右孩子
                if(node->right)
                    Q.push(node->right);
            }
            //获得一层的所有元素后，存到结果数组
            res.push_back(temp);
        }
        return res;
    }
};
```

### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

思路：

类似于之前的遍历，只是改变中间的处理逻辑（相当于之前遍历到每个节点，然后交换每个节点的左右孩子）

```C++
/**********************        递归法       **********************/
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        //终止条件
        if(root == NULL)    return NULL;
        //左
        invertTree(root->left);
        //右
        invertTree(root->right);
        //中,处理逻辑
        swap(root->left, root->right);
        return root;
    }
}; 
/**********************        迭代法       **********************/
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == NULL)    return NULL;
        stack<TreeNode*> st;
        st.push(root);

        while(!st.empty()){
            TreeNode* node = st.top();
            st.pop();
            //改变的只是这里的处理逻辑，对中节点的处理
            swap(node->left, node->right);
            if(node->left)  st.push(node->left);
            if(node->right) st.push(node->right);
        }
        return root;
    }
};
```

### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

思路：

> 返回值：bool
>
> 参数：两个节点（为什么会想到用两个节点）
>
> 终止条件：终止条件就是两个节点先进行比较，如果不满足直接返回，同时也在排除两节点是空的情况
>
> 处理逻辑：后续遍历，根据两节点自身情况和它们下面节点的情况判断

```C++
/******************************         递归法          *********************/
class Solution {
public:
    //自己定义一个函数，传入两个节点
    bool isEqual(TreeNode* left, TreeNode* right){
        //对于两个节点来说，要想判断它是否是轴对称的，那么不仅需要判断其下面是否是对称的，还需要判断两个节点自己
        //终止条件
        //如果两个节点本身都不是对称的，那就不需要看它们下面的节点是否对称了
        //榆次同时也是在排除节点是空的情况，方便后续遍历孩子结点
        if(left == NULL && right != NULL)   return false;
        else if(left != NULL && right == NULL)  return false;
        else if(left == NULL && right == NULL)  return true;
        else if(left->val != right->val)    return false;

        bool leftbool = isEqual(left->left, right->right);
        bool rightbool = isEqual(left->right, right->left); 
        
        return (leftbool && rightbool);       
    }
    //从根节点分化成两个指针，分别向下移动
    bool isSymmetric(TreeNode* root) {
        if(root == NULL)    return true;
        return isEqual(root->left, root->right);
    }
};
```

### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

思路：

求深度，按照正常来说，使用前序遍历，把每层的深度当做参数不断向下传，找到最大的深度

但是，其实也是根节点的高度，也能使用后序遍历，最后返回根节点的高度

```C++
/************************     有点像求高度         ************************/
class Solution {
public:
    int maxDepth(TreeNode* root) {
        //终止条件
        if(root == NULL)    return 0;
        //左
        int left = maxDepth(root->left);
        //右
        int right = maxDepth(root->right);
        //中，处理逻辑
        return max(left, right) + 1;
    }
}; 
/************************     前序遍历，真正的求深度         ************************/
class Solution {
public:
    int maxdepth = 0;
    void preTraversal(TreeNode* root, int depth){
        if(root == NULL)    return;
        //中，处理逻辑
        maxdepth = max(maxdepth, depth);
        //左
        preTraversal(root->left, depth + 1);
        //右
        preTraversal(root->right, depth + 1);
    }
    int maxDepth(TreeNode* root) {
        preTraversal(root, 1);
        return maxdepth;
    }
};
/************************     层序遍历         ************************/
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == NULL)
            return 0;
        //定义一个队列来放指针
        queue<TreeNode*> Q;
        int depth = 0;
        Q.push(root);
        while(!Q.empty()){
            int size = Q.size();
            depth++;
            for(int i = 0;i<size;++i){
                //获得队头元素 然后出队
                TreeNode* node = Q.front();
                Q.pop();             
                if(node->left)  Q.push(node->left);
                if(node->right) Q.push(node->right);
            }
        }
        return count;
    }
};
```

### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

思路：

和最大深度类似

```C++
/******************     层序遍历        ************************/
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root == NULL)    return 0;
        queue<TreeNode*> Q;
        int res = INT_MAX;
        int depth = 0;
        Q.push(root);

        while(!Q.empty()){
            int size = Q.size();
            depth++;
            while(size--){
                TreeNode* node = Q.front();
                Q.pop();
                //如果是叶子结点
                if(node->left == NULL && node->right == NULL){
                    res = min(res, depth);
                    continue;
                }
                if(node->left)  Q.push(node->left);
                if(node->right) Q.push(node->right);
            }
        }
        return res;
    }
};
/******************     递归，前序        ************************/
class Solution {
public:
    int res = INT_MAX;
    void pretraversal(TreeNode* root, int depth){
        //终止条件
        if(root->left == NULL && root->right == NULL){
            res = min(res, depth);
        }
        //因为终止条件改了，这里要保证需要判断的节点不能是空
        if(root->left)  pretraversal(root->left, depth+1);
        if(root->right) pretraversal(root->right, depth+1);
    }
    int minDepth(TreeNode* root) {
        if(root == NULL)    return 0;
        pretraversal(root, 1);
        return res;
    }
};
/*******************************		递归， 后序遍历		****************************/
class Solution {
public:

    int getminDepth(TreeNode* node){
        if(node == NULL)
            return 0;
        //获得左右节点的最小深度
        int leftdepth = getminDepth(node->left);
        int rightdepth = getminDepth(node->right);
        //根据情况判断用哪个作为返回值
        if(node->left == NULL && node->right != NULL)
            return rightdepth + 1;
        if(node->left != NULL && node->right == NULL)
            return leftdepth + 1;

        return min(leftdepth,rightdepth) + 1;

    }

    int minDepth(TreeNode* root) {
        return getminDepth(root);
    }
};
```

### [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

思路：

当成普通二叉树，遍历左右节点，统计节点个数

当成完全二叉树，如果其不是满二叉树，那么向下遍历，其左右子树有可能是满二叉树，最后加上去即可

首先定义两个指针，分别沿着最左边和最右边，看深度是否一样，是满二叉树就按照公式计算，不是就遍历其左右子树

```C++
/**********************************		普通二叉树		*********************************/
class Solution {
public:
    int res = 0;
    void pretraversal(TreeNode* root){
        if(root == NULL)    return;
        res++;
        pretraversal(root->left);
        pretraversal(root->right);
    }
    int countNodes(TreeNode* root) {
        pretraversal(root);
        return res;
    }
};
/**********************************		完全二叉树		*********************************/
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == NULL)    return 0;
        //定义两个指针，分别沿着最左边和最右边，看深度是否一样
        TreeNode* left = root->left;
        TreeNode* right = root->right;

        int leftHeight = 0;
        int rightHeight = 0;
        while(left){
            left = left->left;
            leftHeight++;
        }
        while(right){
            right = right->right;
            rightHeight++;
        }
        //判断是否相等,是否是满二叉树
        if(leftHeight == rightHeight){
            //2的次方运算，就相当于移位运算
            return (2 << leftHeight) - 1;
        }
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

### [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

思路：

对于一棵树，要想判断其是否平衡，需要左右子树的高度，那么就需要函数来获得每个节点的高度。

那么如何表示失衡呢，和正常高度的返回值不同就行。返回值是 -1 就代表失衡

对于一个节点，如果左右子树已经失衡，则就是失衡了，如果左右子树高度差小于等于1，平衡，选择较大的高度当做高度。否则，失衡

```C++
class Solution {
public:
    int posttraversal(TreeNode* root){
        //终止条件
        if(root == NULL)    return 0;

        //左
        int leftHeight = posttraversal(root->left);
        //右
        int rightHeight = posttraversal(root->right);
        //中，处理逻辑
        //如果左右子树不是平衡的，直接返回-1
        //如果两个子树高度差小于等于1，那么选择较高的当做当前节点的高度
        //否则，说明高度差大于1，返回-1
        if(leftHeight == -1 || rightHeight == -1)
            return -1;
        else if(abs(leftHeight-rightHeight) <= 1)
            return max(leftHeight, rightHeight) + 1;
        else
            return -1;
    }
    bool isBalanced(TreeNode* root) {
        return posttraversal(root) == -1 ? false : true;
    }
};
```

### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

思路：



```C++
class Solution {
public:
    vector<string> res;
    void getpath(TreeNode* root, string s){
        //终止条件
        if(root->left == NULL && root->right == NULL){
            res.push_back(s);
            return;
        }
        //遍历孩子结点,每个节点此时的字符串就是刚好的顺序，
        //在传入下一个节点的时候，因为并没有改变 s 的值，所以其实就相当于回溯了
        if(root->left)  getpath(root->left, s +"->" + to_string(root->left->val));
        if(root->right) getpath(root->right, s + "->" + to_string(root->right->val));
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        string str;
        //先判断 根节点是否是空节点
        if(root == NULL)
            return res;
        //先把根节点放入
        str += to_string(root->val);
        getpath(root, str);
        return res;
    }
};
```

### [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

思路：

难点在于需要判断该叶子结点是父节点的左孩子，而不能是右孩子

1、前序遍历：传入两个节点，一个自身，一个父节点，终止条件不仅判断自己是否是叶子结点，还需要判断是否是左孩子

2、后序遍历：先获得左右子树的左叶子之和，如果该节点的左孩子存在，并且是叶子结点，那么需要加上 midvalue

```C++
/*********************************			递归法，前序遍历		*****************************/
class Solution {
public:
    int sum = 0;
    void sumLeft(TreeNode* node, TreeNode* pre){
        //终止条件
        //1、该节点是叶子结点，2、它是父节点的左节点
        if(node->left == NULL && node->right == NULL && node == pre->left){
            sum += node->val;
        }

        if(node->left)  sumLeft(node->left, node);
        if(node->right) sumLeft(node->right, node);
    }
    int sumOfLeftLeaves(TreeNode* root) {
        if(root == NULL)    return 0;
        
        if(root->left)  sumLeft(root->left, root);
        if(root->right) sumLeft(root->right, root);
        return sum;
    }
};
/*********************************			递归法，后序遍历		*****************************/
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(root == NULL)    return 0;
        int leftValue = sumOfLeftLeaves(root->left);        //左
        int rightValue = sumOfLeftLeaves(root->right);      //右
                                                            //中
        int midValue = 0;
        //如果有左节点，并且左节点是叶子结点
        if(root->left && root->left->left == NULL && root->left->right == NULL){
            midValue += root->left->val;
        }
        return leftValue + rightValue + midValue;
    }
};
```

### [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

思路：

1、递归法：类似求每个节点的深度，如果当前的深度的最大的，那么就更新结果的值（因为是先遍历左子树，所以最后一层一定是最左边的节点先访问）

2、迭代法：层序，用每次队列里面的第一个值更新

```C++
/**********************************			递归、前序遍历		*******************************/
class Solution {
public:
    int maxDepth = 0;
    int res = 0;
    void leftValue(TreeNode* node, int depth){
        //终止条件
        if(node == NULL)
            return;
        
        if(depth > maxDepth){
            maxDepth = depth;
            res = node->val;
        }

        leftValue(node->left, depth + 1);
        leftValue(node->right, depth + 1);
    }
    int findBottomLeftValue(TreeNode* root) {
        leftValue(root, 1);
        return res;
    }
};
/**********************************			层序遍历		*******************************/
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        if(root == NULL)    return 0;
        queue<TreeNode*> Q;
        int leftValue = 0;
        Q.push(root);

        while(!Q.empty()){
            int size = Q.size();
            leftValue = Q.front()->val;
            while(size--){
                TreeNode* node = Q.front();
                Q.pop();

                if(node->left)  Q.push(node->left);
                if(node->right) Q.push(node->right);
            }
        }
        return leftValue;
    }
};
```

### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

思路：

递归法：终止条件就是看叶子结点时，剩余值的情况。

```C++
/****************************************		递归法、后序遍历			*********************************/
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        //这个主要是判断根节点是空的情况
        if(root == NULL)
            return false;
        //减去该节点的值，看是否是 0
        targetSum -= root->val;
        //终止条件
        if(root->left == NULL && root->right == NULL){
            if(targetSum == 0)
                return true;
            else
                return false;
        }

        if(root->left)  
           if(hasPathSum(root->left, targetSum))
                return true;
        if(root->right) 
            if(hasPathSum(root->right, targetSum))
                return true;

        return false;
    }
};
```

## 构造二叉树

使用数组来构造二叉树，通常情况是根据下标来确定起始位置。

### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

思路：

递归的根据中序和后序遍历顺序构造，相对于每次都构造新的 vector 传入，直接使用位置截取更快

```C++
class Solution {
public:
    TreeNode* recurrentbuildTree(vector<int>& inorder, int startinorder, int endinorder, vector<int>& postorder, int startpostorder, int endpostorder){
        //终止条件
        if(startinorder < 0 || startinorder > endinorder)
            return NULL;

        //获得根节点的位置
        int rootVal = postorder[endpostorder];
        int rootindex = 0; 
        for(int i = startinorder; i <= endinorder; ++i){
            if(inorder[i] == rootVal){
                rootindex = i;
                break;
            }
        }
        //获得左子树的中序遍历
        int left_start_inorder = startinorder;
        int left_end_inorder = rootindex - 1;
        int left_len = left_end_inorder - left_start_inorder + 1;
        //获得右子树的中序遍历
        int right_start_inorder = rootindex + 1;
        int right_end_inorder = endinorder;
        //获得左子树的后序遍历
        int left_start_postorder = startpostorder;
        int left_end_postorder = startpostorder + left_len - 1;
        //获得右子树的后序遍历
        int right_start_postorder = left_end_postorder + 1;
        int right_end_postorder = endpostorder - 1;
        //构造完成的左子树根节点
        TreeNode* leftTree = recurrentbuildTree(inorder, left_start_inorder, left_end_inorder, postorder, left_start_postorder, left_end_postorder);
        //构造完成的右子树根节点
        TreeNode* rightTree = recurrentbuildTree(inorder, right_start_inorder, right_end_inorder,postorder, right_start_postorder, right_end_postorder);
        //连接
        TreeNode* root = new TreeNode(rootVal);
        root->left = leftTree;
        root->right = rightTree;
        return root;        
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return recurrentbuildTree(inorder, 0, inorder.size()-1, postorder, 0, postorder.size()-1);
    }
};
```

### [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

思路：

构造二叉树，方法就是找到中间节点，获得左右子树的边界，二分构造

```C++
class Solution {
public:
    TreeNode* buildTree(vector<int>& nums, int start, int end){
        //终止条件
        if(start == end)    return NULL;

        //只找到中间节点
        int index = start + (end-start)/2;
        //获得左子树的边界
        int left_start = start;
        int left_end = index;
        //获得右子树的边界
        int right_start = index + 1;
        int right_end = end;

        TreeNode* root = new TreeNode(nums[index]);
        //构建左子树
        root->left = buildTree(nums, left_start, left_end);
        //构建右子树
        root->right = buildTree(nums, right_start, right_end);

        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return buildTree(nums, 0, nums.size());
    }
};
```

### [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

思路：

找到最大的值和位置，递归的构造左右子树

```C++
class Solution {
public:
    TreeNode* constructTree(vector<int>& nums, int begin, int end){
        //终止条件
        if(begin == end)
            return NULL;
        //寻找最大的值
        int maxValue = 0;
        int index = begin;
        for(int i = begin; i < end; ++i){
            if(nums[i] > maxValue){
                maxValue = nums[i];
                index = i;
            }
        }
        //构建根节点
        TreeNode* root = new TreeNode(maxValue);
        root->left = constructTree(nums, begin, index);
        root->right = constructTree(nums, index+1, end);

        return root;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        //终止条件
        if(nums.size() == 0)
            return NULL;
        return constructTree(nums, 0, nums.size());
    }
};
```

### [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

思路：

递归：构造新树，而不是把一棵树加到另一棵树上面

迭代：不构造新树，直接把一棵树加到另外一棵树上面

```C++
/**************************************			递归法			***********************************/
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        //终止条件
        if(root1 == NULL && root2 == NULL)
            return NULL;
       //1是空，2不是空
        else if(root1 == NULL && root2 != NULL){
            return root2;
        }
       //1不是空，2是空
        else if(root1 != NULL && root2 == NULL){
            return root1;
        }

        //构造新的节点合并二叉树
        TreeNode* root = new TreeNode(root1->val + root2->val);
        root->left = mergeTrees(root1->left, root2->left);
        root->right = mergeTrees(root1->right, root2->right);

        return root;
    }
};
/**************************************			迭代法			***********************************/
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(root1 == NULL && root2 == NULL)  return NULL;
        else if(root1 == NULL && root2 != NULL) return root2;
        else if(root1 != NULL && root2 == NULL) return root1;
        queue<TreeNode*> Q;
        Q.push(root1);
        Q.push(root2);
        while(!Q.empty()){
            //取出两个节点，并相加
            TreeNode* node1 = Q.front();Q.pop();
            TreeNode* node2 = Q.front();Q.pop();
            node1->val += node2->val;

            //如果左节点都存在的话
            if(node1->left && node2->left){
                Q.push(node1->left);
                Q.push(node2->left);
            }
            //如果右节点都存在的话
            if(node1->right && node2->right){
                Q.push(node1->right);
                Q.push(node2->right);
            }
            //因为返回的是 root1 ，所以root1不空，root2为空的情况不需要处理了
            //如果 root1 的左边是空，而 root2 的左边不是空的话，就赋值过去
            if(node1->left == NULL && node2->left != NULL)
                node1->left = node2->left;
            if(node1->right == NULL && node2->right != NULL)
                node1->right = node2->right;
        }
        return root1;
    }
};
```

## 二叉搜索树

具有性质，左子树的最大值小于根节点，右子树的最小值大于根节点

- 一般可以使用中序遍历进行操作
- 或者使用一个前驱结点操作

### [700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

思路：

递归法：搜索树具有性质，左边的比根节点小，右边的比根节点大

迭代法：可以不使用栈，直接类似二分搜索法就行

```C++
/*****************************************		递归法		********************************/
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        //终止条件
        if(root == NULL)    return  NULL;
        //中，处理逻辑
        if(root->val == val)
            return root;
        //左、右
        else if(val > root->val)
            return searchBST(root->right, val);
        else
            return searchBST(root->left, val);
    }
};
/*****************************************		迭代法		********************************/
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(root == NULL)    return NULL;
        stack<TreeNode*> st;

        st.push(root);
        while(!st.empty()){
            TreeNode* node = st.top();
            st.pop();
            //中，处理逻辑
            if(node->val == val)
                return node;
            else if(val > node->val){
                if(node->right)
                    st.push(node->right);
            }
            else
                if(node->left)
                    st.push(node->left);
        }

        return NULL;
    }
};
```

### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

思路：

1、一种想法就是中序遍历，然后判断数组是否是单调递增的

2、递归的时候，中序遍历，记录之前的最大值，然后和中间节点比较，但是初始化成最小值的时候，可能存在某个节点是最小值，因此采用前驱结点，中序遍历的时候，比较前驱节点和中间节点的值。同时也要返回左右子树的递归结果

3、迭代法，中序遍历

```C++
/************************       中序遍历法      ****************/
class Solution {
public:
    vector<int> res;
    void inorderTraversal(TreeNode* root){
        if(root == NULL)    return;
        
        inorderTraversal(root->left);
        res.push_back(root->val);
        inorderTraversal(root->right);
    }
    bool isValidBST(TreeNode* root) {
        if(root == NULL)    return true;
        inorderTraversal(root);

        for(int i = 1; i < res.size(); ++i){
            if(res[i] <= res[i-1])
                return false;
        }
        return true;
    }
};
/************************       递归前驱指针法      ****************/
class Solution {
public:
    //判断是否是二叉搜索树需要满足两个条件，对于某个节点
    //一个是左右子树都是二叉搜索树
    //另外一个是当前的值要大于前驱结点的值
    TreeNode* pre = NULL;
    bool isValidBST(TreeNode* root) {
        if(root == NULL)    return true;
        bool left = isValidBST(root->left);

        if(pre != NULL && pre->val >= root->val)
            return false;
        pre = root;

        bool right = isValidBST(root->right);
        return left && right;
    }
};
/************************       迭代法，中序遍历      ****************/
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        if(root == NULL)    return true;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL;
        while(cur != NULL || !st.empty()){
            if(cur != NULL){
                st.push(cur);
                cur = cur->left;
            }
            else{
                TreeNode* node = st.top();
                st.pop();

                if(pre != NULL && pre->val >= node->val)
                    return false;
                pre = node;

                cur = node->right;
            }
        }
        return true;
    }
};
```

### [530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

思路：

和上一题一样，因为是二叉搜索树，那么中序遍历的时候是递增的，要想知道两个节点之间的最小值，必然是相邻的两个节点（中序遍历的相邻节点）之间的差值最小，不然随着递增，后面的数减去前面的数会变大，因此，需要全局记录最小值，并用相邻节点的差值不断更新。
可以使用中序遍历得到数组的方式，也可以采用前驱节点记录。

```C++
/*****************************		递归，中序遍历			************************/
class Solution {
public:
    TreeNode* pre = NULL;
    int res = INT_MAX;
    int getMinimumDifference(TreeNode* root) {
        if(root == NULL)    return 0;
        //左边的值,但是不需要
        getMinimumDifference(root->left);
        if(pre != NULL){
            res = min(res, root->val - pre->val);
        }
        pre = root;
        getMinimumDifference(root->right);
        return res;
    }
};
```

### [501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

思路：

- 普通法：

普通法就是不用二叉搜索树的特性，直接遍历一遍树，然后将数值和频率映射到map里面，但是map并不支持 根据 Value 进行排序，所以需要将 key 和 Value 封装成 pair ，然后自己定义规则，根据频率进行排序。

- 二叉搜索树递归法：

因为中序遍历是有序的，那么在中序遍历的时候，保存一个count的数值，记录相等的数出现的次数，如果后面的和前驱结点的值一样，那么count++，如果不一样，说明已经到了下一个数值了，把count重新设置为1
在过程中对count的值进行判断，如果count和目前已知的最大频率相等，那么就把count对应的节点数值加入到结果数组中，但是如果发现更大的count 比目前已知的频率还要大，那么就直接清空结果数组，然后把该节点的值放入到结果数组中

```C++
/********************************   普通方法    ******************************/
class Solution {
public:
    
    //自己定义排序的函数
    bool static Mycompare(const pair<int,int>& a, const pair<int,int>& b){
        return a.second > b.second;
    }
    //遍历树，将其映射到map里
    void searchTree(TreeNode* node,unordered_map<int,int>& map){
        if(node == NULL)    return;
        map[node->val]++;
        searchTree(node->left,map);
        searchTree(node->right,map);
    }
    vector<int> findMode(TreeNode* root) {
        //定义一个map来保存数和出现的频率
        unordered_map<int,int> map;
        //定义一个vector,根据频率数值排序
        vector<pair<int, int>> vec;
        vector<int> res;
        searchTree(root,map);
        //遍历map,把key 和 value 大打包成pair放入到容器中
        for(auto it = map.begin(); it != map.end(); ++it){
            vec.push_back(make_pair(it->first,it->second));
        }
        //对vector 根据定义的规则，即频率排序
        sort(vec.begin(),vec.end(),Mycompare);

        //最后把vector的第一个找出来，后续和他频率一样的也找出来
        res.push_back(vec[0].first);
        for(int i = 1; i < vec.size(); i++){
            if(vec[i].second == vec[0].second)
                res.push_back(vec[i].first);
        }
        return res;
    }
};
/*********************   二叉搜索树递归法   *********************************/
class Solution {
public:
    vector<int> res;
    int count = 1;
    int max_count = INT_MIN;
    TreeNode* pre = NULL;
    void preTraversal(TreeNode* root){
        //终止条件
        if(root == NULL)    return;

        //左子树
        preTraversal(root->left);
        //中，处理逻辑
        if(pre != NULL){
            if(root->val != pre->val)
                count = 1;
            else
                count++;
        }
        if(count == max_count)
            res.push_back(root->val);

        if(count > max_count){
            max_count = count;
            res.clear();
            res.push_back(root->val);
        }
        pre = root;
        //右子树
        preTraversal(root->right);

    }
    vector<int> findMode(TreeNode* root) {
        if(root == NULL)    return vector<int>{};
        preTraversal(root);
        return res;
    }
};
```

### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

思路：

查找两个节点的公共祖先，如果找到了这两个节点，直接返回它们

对于每个中间节点来说，如果左边或者右边有一个存在，返回它们，如果都存在，说明左右子树各有一个，返回这个中间节点

```C++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        //终止条件,如果是空，就返回空，如果是p或者q，就返回它们自身
        if(root == p || root == q || root == NULL)  return root;

        //获得左右子树的情况
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);

        //判断左右子树是否存在 这两个节点
        //如果两个子树都不存在
        if(left == NULL && right == NULL)
            return NULL;
        else if(left != NULL && right == NULL)
            return left;
        else if(left == NULL && right != NULL)
            return right;
        else
            return root;
    }
};
```

### [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

思路：

在二叉搜索树中，如果 p, q，存在于公共节点的左右子树中，那么公共节点的值一定在区间 [p,q] 之间。因此不需要从下到上的回溯法，直接从根节点向下查找就行，找得到返回就行。

注意：一开始并不知道 p,q 值的相对大小

```C++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        //终止条件
        if(root == NULL)   return root;

        //获得区间范围
        int start = min(p->val, q->val);
        int end = max(p->val, q->val);

        if(start <= root->val && root->val <= end)
            return root;
        else if(root->val < start)
            return lowestCommonAncestor(root->right, p, q);
        else
            return lowestCommonAncestor(root->left, p, q);
    }
};
```

## 二叉树的修改 && 二叉搜索树

对二叉树进行插入，删除操作，因为修改了树的结构，可以构造前驱结点。

另一种方法是返回节点自身，然后递归的时候，分别用左右指针接收，如果没变化，就接收正常的左右孩子，否则就接收改变的左右孩子

### [701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

思路：

整体思路就是从上到下遍历，如果遇到空节点，说明找到了这个位置，构造新节点，关键的是如何连接到之前的树上

- 一个简单的想法是维护一个前驱结点，来加入
- 另一个想法是返回新构造的节点，在递归的时候，直接让左右子树指向递归的节点

```C++
/***************************    递归法    *************************************/
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == NULL) {
            TreeNode* node = new TreeNode(val);
            return node;
        }
        //这太妙了
        if (root->val > val) root->left = insertIntoBST(root->left, val);
        if (root->val < val) root->right = insertIntoBST(root->right, val);
        return root;
    }
};
/**************************		自己写的		********************************/
class Solution {
public:
    TreeNode* pre = NULL;
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == NULL && pre == NULL){
            TreeNode* node = new TreeNode(val);
            return node;
        }
        //找到空节点构造
        if(root == NULL && pre != NULL){
            TreeNode* node = new TreeNode(val);
            if(val > pre->val)
                pre->right = node;
            else
                pre->left = node;
            return root;
        }
        //保存前驱结点
        pre = root;
        if(val < root->val){
            insertIntoBST(root->left, val);
        }
        else if(val > root->val){
            insertIntoBST(root->right, val);
        }
        return root;
    }
};
```

### [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

思路：

首先，搜索出该节点，如果找到就进行处理，如果没找到，根据根节点的值选择遍历左或者右子树，并用左右指针接收返回值

如果找到了，还需要对这个节点的左右子树的情况进行讨论

- 如果左右子树都是空
- 如果存在一个不为空
- 两个都不是空，把左子树插入到右子树的最左边的叶子结点，然后返回右子树

```C++
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        //返回右子树的根节点，同时让左子树的根节点放到右子树的最左边的叶子结点
        //终止条件，
        if(root == NULL)    return NULL;
        //如果找到了
        if(key == root->val){
            //如果左右都是空
            //如果左右有一个不是空
            //如果左右都不是空
            if(root->left == NULL && root->right == NULL)       return NULL;
            else if(root->left == NULL && root->right != NULL)  return root->right;
            else if(root->left != NULL && root->right == NULL)  return root->left;
            else{
                TreeNode* node = root->right;
                while(node->left != NULL)
                    node = node->left;
                node->left = root->left;
                return root->right;
            }
            
        }
        //如果没找到，就左右看看,左右孩子就是返回的节点
        else if(key < root->val)
            root->left = deleteNode(root->left, key);
        else    
            root->right = deleteNode(root->right, key);
        return root;

    }
};
```

### [669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)

思路：

不同于前面两题，这题返回的是正确的节点，而**不是**直接删除不符合的节点

整体思路就是寻找符合条件的节点，然后返回。

- 如果根节点小于左区间，那就找右子树
- 如果根节点大于右区间，那就找左子树
- 如果根节点在区间内，那两边都要找

```C++
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if(root == NULL)    return NULL;

        //如果根节点小于左区间
        if(root->val < low)
            return trimBST(root->right, low, high);
        
        //如果根节点大于右区间
        if(root->val > high)
            return trimBST(root->left, low, high);
        
        //如果根节点恰好在区间内
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};
```

### [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

思路：

因为是二叉搜索树，某个节点的右边的节点都是比其大的，因此，这题需要想到逆序遍历，**右中左**的遍历顺序，这样每遍历一个节点，直接让之前的所有和加上自身节点的值就可以了

```C++
class Solution {
public:
    int sum = 0;
    TreeNode* convertBST(TreeNode* root) {
        //终止条件
        if(root == NULL)    return NULL;

        //先遍历右子树
        convertBST(root->right);
        //中，处理逻辑
        sum += root->val;
        root->val = sum;
        //遍历左子树
        convertBST(root->left);
        return root;
    }
};
```

# 回溯算法

## 组合

给定一个数组，然后从数组中计算有多少组合，满足给定的条件。因为是组合问题，顺序不同视为同一个结果，如 [1,3] 和 [3,1] 是同一个结果

使用回溯法的时候，在向下递归时，应从下一个位置开始递归

终止条件根据题目决定

### [77. 组合](https://leetcode.cn/problems/combinations/)

思路：

可以进行剪枝优化，在递归判断的时候，如果剩下的数全拿都不满足 k 个数，就可以返回了

```C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> res;

    void backtracking(int n, int k, int startIndex){
        // 终止条件
        if(path.size() == k){
            res.push_back(path);
            return;
        }

        //回溯算法
        for(int i = startIndex; i <= n; ++i){
            path.push_back(i);
            backtracking(n, k, i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return res;
    }
};
```

### [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)

思路：

```C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(int k, int n, int startIndex){
        //终止条件
        if(path.size() == k && n == 0){
            res.push_back(path);
            return;
        }

        // 递归回溯
        for(int i = startIndex; i <= 9; ++i){
            path.push_back(i);
            backtracking(k, n - i, i+1);
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum3(int k, int n) {
        backtracking(k, n, 1);
        return res;
    }
};
```

### [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

思路：

本题是从几个不同的数组中选择字母进行组合。在该轮开始时，需要先确定本次所使用的是哪个位置的字符串，然后对字符串进行从前向后的遍历。

本题不需要额外的位置变量记录遍历时候的位置，当是最后一层的时候，直接就是遍历完，如果不是最后一层，从前向后的过程跳到下一层。（遍历的不是同一个数组）

```C++
class Solution {
public:
    //二维数组建立映射 要从 0 开始进行匹配
    const string map[10] = {
        "",
        "",
        "abc",
        "def",
        "ghi",
        "jkl",
        "mno",
        "pqrs",
        "tuv",
        "wxyz"
    };
    string str;
    vector<string> res;  
    void backtracking(const string& digits, int Index){
        if(str.size() == digits.size()){
            res.push_back(str);
            return;
        }
        //选择哪个数字
        //把字符串数字 转成真的数字
        int digit = digits[Index] - '0';
        //把那个数字对应的字符串取出来
        string s = map[digit];
        //遍历该字符串
        for(int i = 0; i < s.size(); ++i){
            str.push_back(s[i]);
            backtracking(digits, Index + 1);
            str.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        str.clear();
        res.clear();
        if(digits == "")    return res;
        backtracking(digits, 0);
        return res;
    }
};
```

### [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

思路：

**注意：该题是无重复元素的！！！！！**
是否需要 startIndex 的问题，如果下一次的取值和之前的没关系就不需要，有关系就需要。本题是有关系的，如果是从0开始，那么存在 2,3和3,2的情况，因此需要 startIndex

终止条件：因为可以无限制的取，所以 target == 0 的情况不够，会出现 target < 0 的情况还会一直执行下去，因此还要加个判断

```C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(const vector<int>& candidates, int target, int startIndex){
        //终止条件
        if(target == 0){
            res.push_back(path);
            return;
        }

        for(int i = startIndex; i < candidates.size() && target > 0; ++i){
            path.push_back(candidates[i]);
            backtracking(candidates, target - candidates[i], i);
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        path.clear();
        res.clear();
        backtracking(candidates, target, 0);
        return res;
    }
};
```

### [40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)

思路：

**去重：**数组中有重复的数，首先排序让相同的数都在一起，在进行遍历的时候，如果和前面一个数相同，那么需要判断是在一个树层上还是在一个树枝上。如果是树层的话，就不行，如果是树枝，可以取

加入 used 数组初始化为 false，如果不是回溯的更新 used 数组，而是在遍历完后把该次遍历的全部设为 true，那么后面的也会变为 true

而采用回溯的更新 used 数组，那么其实最后并没有改变 used 数组的值

```C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(vector<int>& candidates, int target, int startIndex, vector<bool>& used){
        //终止条件
        if(target < 0)  return;
        if(target == 0){
            res.push_back(path);
            return;
        }
        //说明进行循环, 进行了剪枝，就是说，如果选了当前的值 target < 0 了，就不需要进递归了
        for(int i = startIndex; i < candidates.size() && target-candidates[i] >= 0; ++i){
            //如果这次要取的值是之前取过的，就不取，然后拿下一个值
            if(i > 0 && candidates[i-1] == candidates[i] && used[i-1] == false){
                continue;
            }
            path.push_back(candidates[i]);
            target -= candidates[i];
            used[i] = true;
            backtracking(candidates, target, i+1, used);
            used[i] = false;
            target += candidates[i];
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        path.clear();
        res.clear();
        //根据 candidates 的大小创建 used 容器，并都初始化为 false
        vector<bool> used(candidates.size(), false);
        //进行排序
        sort(candidates.begin(),candidates.end());
        backtracking(candidates, target, 0, used);
        return res;
    }
};
```



## 排列

排列和组合的区别在于：

- 排列的顺序不同也是结果，因此需要从头遍历，并不需要 startIndex

- 排列在从头遍历的过程中，对于树枝，需要记录之前已经选择的数，因此需要 used 数组

  

### [46. 全排列](https://leetcode.cn/problems/permutations/)

思路：

从头遍历，不需要 startIndex

需要 used 数组记录之前选择的元素

```C++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        path.clear();
        res.clear();
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return res;
    }
private:
    vector<int> path;
    vector<vector<int>> res;

    void backtracking(const vector<int>& nums, vector<bool>& used){
        //终止条件，path到达了最后一个元素
        if(path.size() == nums.size()){
            res.push_back(path);
            return;
        }

        for(int i = 0; i < nums.size(); ++i){
            //如果这个数值在这个树枝用过
            if(used[i] == true)
                continue;
            path.push_back(nums[i]);
            used[i] = true;
            backtracking(nums, used);
            used[i] = false;
            path.pop_back();
        }
    }
};
```

### [47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)

思路：

本题是全排列，需要树枝去重，使用 used 去重

有重复元素，需要树层去重，可以排列后用 used 去重

```C++
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        path.clear();
        res.clear();
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end());
        backtracking(nums, used);
        return res;
    }

private:
    vector<int> path;
    vector<vector<int>> res;

    void backtracking(const vector<int>& nums, vector<bool>& used){
        //终止条件
        if(path.size() == nums.size()){
            res.push_back(path);
            return;
        }

        //  
        for(int i = 0; i < nums.size(); ++i){
            //如果在这一树枝上出现过，或者在同一树层出现过，那么就下一个
            if(used[i] == true || (i > 0 && nums[i] == nums[i-1] && used[i-1] == false))
                continue;
            
            path.push_back(nums[i]);
            used[i] = true;
            backtracking(nums, used);
            used[i] = false;
            path.pop_back();

        }
    }
};
```



## 分割

### [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)

思路：

回溯法的参数：维护一个指针，从这里开始，然后向后遍历，如果是回文字符串，那么就放入到过程数组中，然后从下一个位置开始，继续递归的判断。

```C++
class Solution {
public:
    //存放分割的回文字符串
    vector<string> path;
    //存放结果
    vector<vector<string>> res;
    void backtracking(const string& str, int index){
        //终止条件,如果起点index 已经到终点了
        if(index == str.size()){
            //放到结果里
            res.push_back(path);
            return;
        }

        //循环，判断是否是回文
        for(int i = index; i < str.size(); ++i){
            //如果是回文串，就放入到路径中
            if(palindromeString(str, index, i)){
                path.push_back(str.substr(index, i - index + 1));
                backtracking(str, i + 1);
                path.pop_back();
            }
        }
    }

    vector<vector<string>> partition(string s) {
        //如果是空，就返回空
        if(s.size() < 1)
            return vector<vector<string>>{};

        backtracking(s, 0);
        return res;
    }

    bool palindromeString(const string& str, int start, int end){
        //如果左边大于右边，错误的参数
        if(start > end)
            return false;

        while(start < end){
            if(str[start] != str[end])
                return false;

            start++;
            end--;    
        }
        return true;
    }
};
```

### [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

思路：

第一眼想的是像之前一样，分割出来，存到新的数组中。但是不如直接在原字符串上进行改动

终止条件不是说到了末尾，而是当 . 的数量已经插入三个之后，直接进行判断，后面的符合条件就放进去，不符合就return

在处理的过程中也需要注意，insert 就是在当前位置插入，而不是当前位置前面插入。注意 erase 的用法。

判断是否有非法字符，是否属于 0-255 区间

```C++
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        //如果存在其他字符串，直接返回
        for(int i = 0; i < s.size(); ++i){
            if(s[i] - '0' > 9)
                return vector<string>{};
        }
        res.clear();
        backtracking(s, 0);
        return res;
    }


private:
    vector<string> res;
    int numDot = 3;
    void backtracking(string& str, int startIndex){
        //终止条件
        if(numDot == 0){
            if(isIP(str, startIndex, str.size() - 1))
                res.push_back(str);
            return;
        }

        //循环判断，是否可行
        for(int i = startIndex; i < str.size(); ++i){
            //如果是属于 0-255，说明可以
            if(isIP(str, startIndex, i)){
                //放入到数组中
                str.insert(str.begin() + i + 1, '.');
                numDot--;
                backtracking(str, i + 2);
                numDot++;
                str.erase(str.begin() + i + 1);
            }
        }
    }
    
    //判断是否属于 0-255
    bool isIP(const string& str, int start, int end){
        if(start > end)
            return false;
        
        //如果第一个是 0 ，并且不止一个数，那就是错的
        if(end - start > 0 && str[start] == '0')
            return false;

        long num = stol(str.substr(start, end - start + 1));
        if(num >= 0 && num <= 255)
            return true;

        return false;
    }
};
```



## 子集

子集问题和组合问题比较像，但是子集问题是收集所有的过程节点，并非是叶子结点。

###  [78. 子集](https://leetcode.cn/problems/subsets/)

思路：

首先是 是否需要 startIndex 的问题，因为需要收集的结果是跟前面有关系的，不能存在 1 2， 2 1 这样的重复组合

其次就是空集也需要加入集合中，放在终止条件的前面

```C++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        path.clear();
        res.clear();
        backtracking(nums, 0);
        return res;
    }

private:
    vector<int> path;
    vector<vector<int>> res;

    void backtracking(const vector<int>& nums, int startIndex){
        //先收集结果，这样不会漏掉空集
        res.push_back(path);
        //终止条件，如果探索的长度是最后了
        if(startIndex >= nums.size())
            return;    

        for(int i = startIndex; i < nums.size(); ++i){
            path.push_back(nums[i]);
            backtracking(nums, i+1);
            path.pop_back();
        }
    }
};
```

###  [90. 子集 II](https://leetcode.cn/problems/subsets-ii/)

思路：

和上一题的区别在于这次集合里面有重复元素，需要进行去重

本题的去重是属于树层去重，同一树枝并不需要进行去重。

而是用 used 数组进行判断的时候，因为同一树枝的，前面重复的 used 是 true ，那么对于该数仍然是可以取的

而同一树层，因为前面的重复数已经遍历到底了，此时 used 是 false，而同一树层是不能取的，因此判断条件是 used 为 false

```C++
class Solution {
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        path.clear();
        res.clear();
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end());
        backtracking(nums, 0, used);
        return res;
    }

private:
    vector<int> path;
    vector<vector<int>>res;

    void backtracking(const vector<int>& nums, int startIndex, vector<bool>& used){
        res.push_back(path);
        //终止条件
        if(startIndex >= nums.size())
            return;
        
        for(int i = startIndex; i < nums.size(); ++i){
            //去重,注意这里的used是 false
            if(i > 0 && nums[i] == nums[i-1] && used[i-1] == false)
                continue;
            
            //正常操作
            path.push_back(nums[i]);
            used[i] = true;
            backtracking(nums, i+1, used);
            used[i] = false;
            path.pop_back();
        }
    }
};
```

### [491. 递增子序列](https://leetcode.cn/problems/increasing-subsequences/)

思路：

本题和 子集II 类似，也是需要进行去重操作，同样是树层去重

区别在于，本题的序列并不是有序的，而且求递增，并不能改变原数组的相对顺序

所以去重不能使用之前的那种排序的方式，因此这里需要在每一层开始的时候，构建一个 set 容器，里面保存这层用过的元素。如果后面查询到在 set 数组中，直接下一个数

**注意：set 数组是在每一层里面创建的，因此只在这一层生效，递归进入下一层的时候，会重新创建，并不会影响结果** 

```C++
class Solution {
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        path.clear();
        res.clear();

        backtracking(nums, 0);
        return res;
    }

private:
    vector<int> path;
    vector<vector<int>> res;
    

    void backtracking(const vector<int>& nums, int startIndex){
        //加入到 res 数组中，如果 path 里面的数超过了两个
        if(path.size() >= 2)
            res.push_back(path);
            
        //终止条件，到达最后的位置了
        if(startIndex >= nums.size())
            return;

        unordered_set<int> used;
        for(int i = startIndex; i < nums.size(); ++i){
            //如果不满足条件就下一个
            if((path.size() > 0 && nums[i] < path.back()) || used.find(nums[i]) != used.end())
                continue;
            //去重

            path.push_back(nums[i]);
            used.insert(nums[i]);
            backtracking(nums, i+1);
            path.pop_back();
        }
    }
};
```



## 其他

### [332. 重新安排行程](https://leetcode.cn/problems/reconstruct-itinerary/)

思路：

本题作为 hard 题目，有以下难点：

1、进行寻找的时候，是否会出现死循环的现象

2、是否用完所有的机票，是否每个城市都经过

3、一个机场对应多个目的机场怎样处理，机场还需要进行字典序排序

采用回溯法进行处理，解决以上问题

1、终止条件是航班数加一

2、把出发机场和多个目的机场进行映射，同时 map 会自动对目标机场进行字典序排序，unordered_map<起始机场，map<目的机场，航班数量>>

3、backtracking 的返回值是 bool 类型，只要找到一个结果，那么就直接返回，并且是正确的

```C++
class Solution {
public:
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        res.clear();
        res.push_back("JFK");
        //记录映射关系
        for(const vector<string>& vec : tickets){
            //按照起始地，目的地进行映射
            target[vec[0]][vec[1]]++;
        }
        backtracking(tickets);
        return res;
    }

private:
    //定义一个结果字符串数组存储
    vector<string> res;
    //定义一个起始地到目的地所有航班的映射关系
    //unordered_map<起始机场，map<目的机场，航班数量>>, 其中目的机场使用 map, 会自动排序
    unordered_map<string, map<string, int>> target;

    //backtracking 返回值是 bool ，只要找到符合条件的直接返回（因为已经是排序好的）
    bool backtracking(const vector<vector<string>>& tickets){
        //终止条件，收集的结果 是航班数加一
        if(res.size() == tickets.size() + 1){
            return true;
        }

        //上个机场作为出发机场，寻找可用的航班
        for(pair<const string, int>& num : target[res.back()]){
            //如果以 pair 作为航班还有次数
            if(num.second > 0){
                //进行处理
                res.push_back(num.first);
                num.second--;
                if(backtracking(tickets) == true)   return true;
                num.second++;
                res.pop_back();
            }
        }
        return false;
    }

};
```

### [51. N 皇后](https://leetcode.cn/problems/n-queens/)

思路：

首先构造棋盘，实际上只需要一个 vector<string> 就可以进行表示了

然后就是一层一层的向下递归，再回溯

```C++
class Solution {
public:
    vector<vector<string>> res;
    void backtracking(vector<string>& path, const int n, int row){
        if(row == n){
            res.push_back(path);
            return;
        }
        for(int column = 0; column < n; ++column){
            //如果这个位置不能放，就找下一个
            if(!isValid(path, row, column)){
                continue;
            }
            path[row][column] = 'Q';
            backtracking(path, n, row + 1);
            path[row][column] = '.';
        }
    }
    //首先写一个函数判断 这个位置能不能放
    bool isValid(vector<string>& path, int row, int column){
        //首先判断这一列有没有
        for(int i = 0; i <= row; i++){
            if(path[i][column] == 'Q')
                return false;
        }

        //然后判断左上方
        for(int i = row - 1, j = column - 1; i >= 0 && j >= 0; i--,j--){
            if(path[i][j] == 'Q')
                return false;
        }

        //判断右上方
        for(int i = row - 1, j = column + 1; i >= 0 && j < path.size(); i--, j++){
            if(path[i][j] == 'Q')
                return false;
        }
        return true;
    }
    vector<vector<string>> solveNQueens(int n) {
        vector<string> path(n, string(n, '.'));
        backtracking(path, n, 0);
        return res;
    }
};
```

### [37. 解数独](https://leetcode.cn/problems/sudoku-solver/)

思路：

这里主要是需要进行二维的回溯，并且回溯函数是有返回值的，这样的话，只要找到一个符合条件的，就可以直接返回了

```C++
class Solution {
public:
    bool backtracking(vector<vector<char>>& board){
        //遍历所有位置
        for(int i = 0; i < 9; ++i){
            for(int j = 0; j < 9; ++j){
                //如果该位置有数，就下一个位置
                if(board[i][j] != '.')
                    continue;
                //从1-9 进行遍历
                for(char k = '1'; k <= '9'; ++k){
                    //如果该位置填上 数字是有效的话
                    if(isValid(board, i, j, k)){
                        board[i][j] = k;
                        //回溯， 但是因为有返回值，所以进行判断，
                        //其实回溯也是从头进行二维遍历
                        if(backtracking(board))
                            return true;
                        board[i][j] = '.';
                    }
                }
                // 这个位置 9 个数都不行，直接 false 就行了
                return false;
            }
        }
        //遍历完了返回 true
        return true;
    }

    //判断该位置是否合法
    bool isValid(const vector<vector<char>>& board, int row, int column, const char c){
        //首先应该判断这一行
        for(int j = 0; j < 9; j++){
            //如果该行 的这个位置之前出现过这个元素，直接返回
            if(board[row][j] == c)
                return false;
        }

        //判断 该列 之前是否出现过这个字符
        for(int i = 0; i < 9; i++){
            if(board[i][column] == c)
                return false;
        }
        int row_init = (row/3) * 3;
        int column_init = (column/3) *3;
        //判断九宫格内是否出现过这个元素
        for(int i = row_init; i < row_init + 3; i++){
            for(int j = column_init; j < column_init + 3; j++){
                if(board[i][j] == c)
                    return false;
            }
        }
        return true;
    }
    void solveSudoku(vector<vector<char>>& board) {
        backtracking(board);
    }
};
```

# 贪心算法

### [455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)

思路：

先满足胃口小的

```C++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        //对胃口和饼干进行排序，从小到大
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());

        int num = 0;
        //从胃口小的孩子进行选择
        for(int i = 0, j = 0; i < g.size() && j < s.size(); ++j){
            //判断条件
            if(s[j] >= g[i]){
                num++;
                ++i;
            }
        }
        return num;
    }
};
```

### [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

思路：

只需要找到谷峰和谷底的个数就行了，也就是两边的差值相反，而中间的元素都是可以 ”删除“ 的

注意判断条件，pre 与 cur 的判断方式

```C++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        //定义前面的差值和后面的差值
        int preDiff = 0;
        int curDiff = 0;
        //从 1 开始是因为，至少有一个峰值，也就是只要大于两个数，都会是 2
        int res = 1;

        for(int i = 0; i < nums.size() - 1; ++i){
            curDiff = nums[i+1] - nums[i];
            //如果存在当前的元素是和之前的正负相反
            // pre可以等于 0 是因为初始化是0 ，但是在后续的赋值过程中，是不可能等于 0 的
            if((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >=0)){
                res++;
                preDiff = curDiff;
            }
        }
        return res;
    }
};
```

```C++
/****************************************         动规        **********************************************/
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        //dp[i][0] 表示到 i 位置为谷峰时候的摆动序列数
        //dp[i][1] 表示到 i 位置为谷底时候的摆动序列数
        vector<vector<int>> dp(nums.size(), vector<int>(2, 0));
        
        //dp 数组初始化
        dp[0][0] = 1;
        dp[0][1] = 1;

        //循环
        for(int i = 1; i < nums.size(); ++i){
            //这个地方不明白呀！！！
            dp[i][0] = 1, dp[i][1] = 1;
            //for循环找谷底
            for(int j = 0; j < i; ++j){
                //如果可以当做谷底
                if(nums[j] > nums[i]){
                    dp[i][1] = max(dp[j][0] + 1, dp[i][1]);
                }
            }

            //for循环寻找谷峰
            for(int j = 0; j < i; ++j){
                if(nums[j] < nums[i]){
                    dp[i][0] = max(dp[j][1] + 1, dp[i][0]);
                }
            }
        }
        return max(dp[nums.size()-1][0], dp[nums.size()-1][1]);
    }
};
```

### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

思路：

到达某个位置的时候，如果前面的和已经是负数了，那么就会拖累，直接舍弃，重新开始求和

**不能让“连续和”为负数的时候加上下一个元素，而不是 不让“连续和”加上一个负数**

```C++
/****************************************         贪心        **********************************************/
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int res = INT_MIN;
        int sum = -1;
        for(int i = 0; i < nums.size(); ++i){
            //如果之前的和已经是负数了，直接舍弃，重新开始
            if(sum <= 0){
                sum = nums[i];
            }
            else
                sum += nums[i];
            res = max(res, sum);
        }
        return res;
    }
};
```

```C++
/****************************************         动规        **********************************************/
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        //dp[i]表示以 i 结尾的最大子序列和
        vector<int> dp(nums.size(), INT_MIN);

        //初始化
        dp[0] = nums[0];
        int res = nums[0];
        //for循环
        for(int i = 1; i < nums.size(); ++i){
            dp[i] = max(dp[i-1] + nums[i], nums[i]);
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

### [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

思路：

这里关键的不是每次跳多少步，而是计算覆盖范围，如果能覆盖到终点，就一定能跳过去

```C++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int maxLength = 0;
        for(int i = 0; i < nums.size() && i <= maxLength; ++i){
            maxLength = max(maxLength, i + nums[i]);
        }
        return maxLength >= (nums.size() - 1) ? true : false;
    }
};
```

### [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

思路：

在当前覆盖范围内，找到下次能够覆盖的最大范围

如果当前覆盖范围内走完了还没到终点，那么必须在当前覆盖范围内的某个地方进行跳跃一步，因此步数加一，然后更新覆盖范围

```C++
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size() == 1) return 0;
        int res = 0;
        int cur_cover = 0;
        int next_cover = 0;
        //遍历每个元素
        for(int i = 0; i < nums.size(); ++i){
            //计算 cur_cover 里面的每个元素能够跳的最远距离
            //也就是下一次能够覆盖的范围
            next_cover = max(next_cover, i + nums[i]);

            //如果已经到了这次覆盖范围的最后，还没有到终点
            if(i == cur_cover && i != (nums.size() - 1)){
                res++;
                cur_cover = next_cover;
            }
        }
        return res;
    }
};
```

### [1005. K 次取反后最大化的数组和](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/)

思路：

根据绝对值进行排序，碰到负数并且有 k 值，进行反转

如果到最后一个了，还有 k 值，一直反转这一个就行了（看 k 的奇偶）

```C++
class Mycompare{
public:
    bool operator() (const int a, const int b){
        return abs(a) > abs(b);
    }
};


class Solution {
public:
    int largestSumAfterKNegations(vector<int>& nums, int k) {
        //遇事不决先排序，按照绝对值的大小排序
        sort(nums.begin(), nums.end(), Mycompare());
        int sum = 0;
        for(int i = 0; i < nums.size();++i){
            //如果是负数，并且还有 k 的话，就把负数变正
            if(nums[i] < 0 && k > 0){
                nums[i] *= -1;
                --k;
            }
            
            //如果到最后一个了，还有 k 值
            if(i == nums.size() - 1 && k > 0){
                //如果k是奇数，反转一下
                if(k%2 != 0)
                    nums[i] *= -1;
            }
            sum += nums[i];
        }
        return sum;
    }
};
```

### [134. 加油站](https://leetcode.cn/problems/gas-station/)

思路：

首先，如果油量和减去总消耗和是负数，肯定是不行的

其次，很容易想到从某个位置开始遍历，如果加的油减去消耗的油小于零，那么说明无法到达这里！

但是从每个节点开始进行循环，时间复杂度非常高，那么在到达某一个位置的时候，油量小于零的情况怎么处理呢

从某个起始位置到达当前节点的油量和小于零，那么其中间的任意一个位置都不能当做起点！！！而是当前位置的下一个作为起点

- 如果起始位置的油量和是正的，那么中间的其他节点到当前位置的油量和更加是负的，更不可能到达
- 如果起始位置的油量和是负的，那么刚好从下一个位置开始，是符合定义的

```C++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        //变量记录从起始位置到当前位置的油量和
        int curSum = 0;
        //变量记录所有位置的油量和
        int totalSum = 0;
        //定义起始位置
        int start = 0;

        //for循环进行遍历
        for(int i = 0; i < gas.size(); ++i){
            //计算当前油量和
            curSum += gas[i] - cost[i];
            //计算总共的油量和
            totalSum += gas[i] - cost[i];

            //如果存在某个位置的油量和是负数
            if(curSum < 0){
                //清空油量和
                curSum = 0;
                //更换起始位置
                start = i + 1;
            }
        }
        //如果总共的油量和是负数
        if(totalSum < 0)
            return -1;
        else
            return start;
    }
};
```

### [135. 分发糖果](https://leetcode.cn/problems/candy/)

思路：

难点在于贪心的策略，如果在考虑局部的时候想两边兼顾，就会顾此失彼

本题采用了两次贪心的策略：

- 一次是从左到右遍历，只比较右边孩子评分比左边大的情况
- 一次是从右到左遍历，只比较左边孩子评分比右边大的情况

这样从局部最优推出了全局最优，即：相邻的孩子中，评分高的孩子获得更多的糖果

```C++
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> nums(ratings.size(), 1);
        int sum = 0;

        //先从左到右遍历一遍
        for(int i = 1; i < ratings.size(); ++i){
            //如果右边的孩子比左边的孩子评分高，那就在左边的基础上加一
            if(ratings[i] > ratings[i-1]){
                nums[i] = nums[i-1] + 1;
            }
        }

        //然后从右向左遍历一遍
        for(int i = nums.size() - 2; i >= 0; --i){
            if(ratings[i] > ratings[i+1])
                nums[i] = max(nums[i], nums[i+1] + 1);
        }

        for(int i = 0; i < nums.size(); ++i)
            sum += nums[i];

        return sum;
    }
};
```

### [860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)

思路：

贪心：对于 20 元，优先使用 10 元的，再使用 5 元的

```C++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        //分别创建每个面额的数组
        int five = 0, ten = 0, twenty = 0;

        for(int i = 0; i < bills.size(); ++i){
            //判断收入的面额
            if(bills[i] == 5){
                five += 1;
            }
            else if(bills[i] == 10){
                //如果不能找零的话，直接false
                if(five < 1)
                    return false;

                five -= 1;
                ten += 1;
            }
            else{
                //如果能够找零，有两种情况
                if(five >= 1 && ten >= 1){
                    five -= 1;
                    ten -= 1;
                    twenty += 1;
                }
                else if(five >= 3){
                    five -= 3;
                    twenty += 1;
                }
                else
                    return false;
            }
        }
        return true;
    }
};
```

### [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)

思路：

首先需要确定一个维度，然后才能进行排序，两个维度同时就会顾此失彼，关键是需要确定哪个维度

先按身高来排序，因为 k 值是根据身高进行确定的

按身高排序之后，就可以直接插入了，因为当插入后面的元素时候，前面的身高比它高的都插入完成，只要找到它的位置直接插入就行了

**使用 list 插入会比 vector 更加有效率**

```C++
class Solution {
public:
    static bool compare(const vector<int> a, const vector<int> b){
        //如果两个的身高相等,优先返回 第二个 属性小的
        if(a[0] == b[0])    return a[1] < b[1];
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        //首先对 people 容器根据身高进行排序，从大到小
        sort(people.begin(), people.end(), compare);
        //然后对排序后的 容器进行插入到 list（节省时间）
        list<vector<int>> list;
        for(int i = 0; i < people.size(); ++i){
            //获得 每个人的插入位置
            int position = people[i][1];
            auto it = list.begin();
            //不停的找位置
            while(position--){
                it++;
            }
            list.insert(it, people[i]);
        }
        return vector<vector<int>>(list.begin(), list.end());
    }
};
```

### [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

思路：

属于区间问题，对于区间问题，首先需要进行排序，根据起点从小到大进行排序

然后比较终点的位置，找到重叠的部分，这里有两种思想：

- 看前一个的终点是否覆盖到了这个位置的起点，如果**没覆盖到**，就一定需要 num++。**如果覆盖到了，那么就更新该位置的终点**，为 前一个位置的终点和该位置终点的最小值
- 维护一个区间，用来表示能够射箭的范围，到每一个位置的时候进行判断，区间取 左边和当前起点的最大值，右边和当前终点的最小值。如果区间不正常了，那么就需要进行 num++，并且还需要更新区间的值

```C++
class Solution {
public:
    static bool Compare(const vector<int>& a, const vector<int>& b){
        if(a[0] == b[0]){
            return a[1] < b[1];
        }
        return a[0] < b[0];
    }

    int findMinArrowShots(vector<vector<int>>& points) {
        //按照第一个数从小到大进行排序
        sort(points.begin(), points.end(), Compare);

        //然后比较第二个数的大小
        int num = 1;
        int left = points[0][0], right = points[0][1];
        for(int i = 1; i < points.size(); ++i){
            //计算能够射箭的区间
            left = max(left, points[i][0]);
            right = min(right, points[i][1]);

            //如果能够射箭的区间 不是正常区间，左边大于右边，那么直接 num++
            if(left > right){
                num++;
                left = points[i][0];
                right = points[i][1];
            }
        }
        return num;
    }
};
```

### [435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)

思路：

区间问题，首先按照起点从小到大进行排序，庵后判断终点的情况

如果该位置的起点比上一个的终点还要小，说明重叠，此时需要删除一个区间，同时更新该位置的终点，为上个位置的终点和该位置终点的最小值

```C++
class Solution {
public:
    static bool Compare(const vector<int>& a, const vector<int>& b){
        if(a[0] == b[0])
            return a[1] < b[1];
        
        return a[0] < b[0];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        sort(intervals.begin(), intervals.end(), Compare);

        int num = 0;
        //循环遍历
        for(int i = 1; i < intervals.size(); ++i){
            //如果存在重叠区间，那么就处理
            if(intervals[i][0] < intervals[i-1][1]){
                num++;
                intervals[i][1] = min(intervals[i][1], intervals[i-1][1]);
            }
        }
        return num;

    }
};
```

### [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

思路：

把每个字符的最远位置映射到数组，然后再进行遍历，同时更新每次出现的字符的最远位置，作为边界

如果到达边界，说明这段字符串里面的字符已经全都找完了，然后更新边界，数量

```C++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        unordered_map<char, int> nums;
        vector<int> res;
        //遍历一遍，得到每个字符的最远距离
        for(int i = 0; i< s.size(); ++i){
            nums[s[i]] = i; 
        }

        //再进行遍历，得到每个划分段的长度
        int num = 0; 
        int length = nums[s[0]];
        for(int i = 0; i < s.size(); ++i){
            num++;
            length = max(length, nums[s[i]]);
            //如果已经达到了边界
            if(i == length){
                res.push_back(num);
                num = 0;
                length += 1; 
            }
        }
        return res;
    }
};
```

### [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

思路：

- 第一种方法是，如果该位置的起点比前一个的终点大，说明不重叠，此时把区间加入到结果里面。如果重叠，那么更新该位置的起点和终点为 **合并区间的起点，终点**。对于最后一个区间，需要单独加入
- 法二就是，直接把区间加入到结果里面，比较最后一个元素的终点和下一个区间的起点，如果重叠，更新最后一个元素的终点为较大值。如果不重叠，直接加入到结果里

```C++
class Solution {
public:
    static bool compare(const vector<int>& a, const vector<int>& b){
        if(a[0] == b[0])    return a[1] < b[1];
        return a[0] < b[0];
    }
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        int n = intervals.size();
        sort(intervals.begin(), intervals.end(), compare);
        
        for(int i = 1; i < intervals.size(); ++i){
            //如果该位置的起点比前一个位置的终点大，说明不能重叠，这时候要进行处理
            if(intervals[i][0] > intervals[i-1][1]){
                res.push_back({intervals[i-1][0], intervals[i-1][1]});
            }
            else{
                intervals[i][0] = min(intervals[i][0], intervals[i-1][0]);
                intervals[i][1] = max(intervals[i][1], intervals[i-1][1]);
            }
        }
        res.push_back({intervals[n-1][0], intervals[n-1][1]});
        return res;
    }
};
/***********************************		法二，直接加入并且合并			***********************************/
class Solution {
public:
    static bool compare(const vector<int>& a, const vector<int>& b){
        if(a[0] == b[0])    return a[1] < b[1];
        return  a[0] < b[0];
    }
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        //按照起始位置从小到大 进行排列
        sort(intervals.begin(), intervals.end(), compare);
        vector<vector<int>> res;
        res.push_back(intervals[0]);
        for(int i = 0; i < intervals.size(); ++i){
            //如果存在重叠区间,那么更新区间的终点
            if(intervals[i][0] <= res.back()[1]){
                res.back()[1] = max(res.back()[1], intervals[i][1]);
            }
            else{
                // 不重叠的区间直接放进去，然后再不断地更新终点
                res.push_back(intervals[i]);
            }
        }
        return res;
    }
};

```

### [738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)

思路：

对于数字，希望获得每一位的数字，转化为字符串更加方便操作

如果碰到顺序不对的，把前一位减一，后面的变成 9，这样就能符合条件了

从前向后遍历的话，是行不通的，选择从后向前遍历，同时记录下转变的位置，方便后续变成 9 的操作

```C++
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        //把数字变成字符串更容易 读取里面的每个字符
        string str = to_string(n);
        //用一个 flag 标记，表示后面的数全部都变成 9
        int flag = str.size();
        //从后向前遍历
        for(int i = str.size() - 1; i > 0; --i){
            //如果前面的数比当前的数要大
            if(str[i-1] > str[i]){
                str[i-1]--;
                flag = i;
            }
        }
        //最后把 flag 及后面的数都变成9
        for(int i = flag; i < str.size(); ++i){
            str[i] = '9';
        }
        return stoi(str);
    }
};
```

### [968. 监控二叉树](https://leetcode.cn/problems/binary-tree-cameras/)

思路：

让放置的摄像头最少，肯定是隔几个才进行放置，那么有两种选择，根节点不放，或者叶子结点不放

从叶子结点进行考虑比根节点好，因为叶子结点的个数很多，能够省下来的数量是指数级的

然后选择从下到上的后序遍历，对于每个节点的三种状态分别定义三个数

> 0:表示该节点无覆盖
> 1:表示该节点有摄像头
> 2:表示该节点有覆盖

判断出现的几种情况：

1、左右节点都是有覆盖的情况，此时该节点就是 无覆盖0

2、左右存在无覆盖，此时该节点要放置摄像头监控，返回 1

3、左右存在摄像头，那么该节点处于有覆盖的状态，返回 2

4、最后对于根节点，如果返回的是无覆盖的情况，那么没有父节点放置摄像头了，因此自己放置

```C++
/*
0:表示该节点无覆盖
1:表示该节点有摄像头
2:表示该节点有覆盖
*/
class Solution {
public:
    int minCameraCover(TreeNode* root) {
        //如果头结点是无覆盖的情况，那么就放置摄像头
        if(traversal(root) == 0)
            res++;
        return res;
    }
private:
    int res = 0;
    int traversal(TreeNode* node){
        //终止条件, 如果遇到空节点，直接返回状态 2
        if(node == NULL)    return 2;

        int left = traversal(node->left);
        int right = traversal(node->right);
        //如果左右节点都是有覆盖，那么就返回 0
        if(left == 2 && right == 2) return 0;
        //如果两边有一个是无覆盖的，就返回 1
        else if(left == 0 || right == 0){
            res++;
            return 1;
        }
        else if(left == 1 || right == 1) return 2;

        return -1;
    }
};
```

### [646. 最长数对链](https://leetcode.cn/problems/maximum-length-of-pair-chain/)

思路：

类似于无重叠区间问题，按照第二个数进行排序之后，贪心选择最优解

注意当不符合条件的时候，需要更新当前节点的第二个值

```C++
class Solution {
public:
    static bool Compare(const vector<int>& v1, const vector<int>& v2){
        // if(v1[0] == v2[0])  return v1[1] < v2[1];
        // return v1[0] < v2[0];
        //这里选择的是按照第二个数从小到大排序
        if(v1[1] == v2[1])  return v1[0] < v2[0];
        return v1[1] < v2[1];
    }
    int findLongestChain(vector<vector<int>>& pairs) {
        //贪心，先排序，然后选择区间跨度最小的
        sort(pairs.begin(), pairs.end(), Compare);
        // for(int i = 0; i < pairs.size(); ++i){
        //     cout << pairs[i][0] << " " << pairs[i][1] << endl;
        // }
        //定义一个数保存已经找到的长度
        int res = 1;
        //遍历每一个数对
        for(int i = 1; i < pairs.size(); ++i){
            if(pairs[i-1][1] < pairs[i][0])
                res++;
            else
                pairs[i][1] = pairs[i-1][1];
        }
        return res;
    }
};
```



# 动态规划

## 打家劫舍

### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

思路：

- dp[i] 表示偷到 i 位置时，所获得的最大金额

递推公式：每次到达一个房间的时候，可以选择偷或者不偷这个房间的，如果偷，是 dp[i-2] + nums[i]，不偷，是 dp[i-1]，选较大的那个

dp[i] = max(dp[i-1], dp[i-2] + nums[i])

初始化，前两个房间，第一个是自身，第二个是前两个较大的，注意是否有两个房间

循环，就是从前向后

```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        //只有一个房间可以选择
        if(nums.size() < 2) return nums[0];
        //dp[i] 表示偷到 i 位置时，所获得的最大金额
        vector<int> dp(nums.size(), 0);
        //初始化
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        //for循环遍历
        for(int i = 2; i < nums.size(); ++i){
            //不拿或者拿
            dp[i] = max(dp[i-1], dp[i-2] + nums[i]);
        }
        return dp[nums.size()-1];
    }
};
```

### [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

思路：

两种情况：

不偷第一家，最后一家可偷可不偷

偷第一家，最后一家必不可偷

找到两个里面最大的

```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() <= 1)    return nums[0];
        //去掉最后一个
        int res1 = rob_args(nums, 0, nums.size()-1);
        //去掉第一个
        int res2 = rob_args(nums, 1, nums.size());
        //返回最大的
        return max(res1, res2);
    }
private:
    //带参数的 打家劫舍 1
    int rob_args(vector<int>& nums, int start, int end){
        int size = end - start;
        if(size <= 1)    return nums[start];
        vector<int> dp(size, 0);
        dp[0] = nums[start];
        dp[1] = max(nums[start], nums[start+1]);
        for(int i = 2; i < size; ++i){
            dp[i] = max(dp[i-1], dp[i-2] + nums[start+i]);
        }
        return dp[size-1];
    }
};
```

### [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

思路：

该题需要想到，对于二叉树上的每个节点，有两种情况，**偷或者不偷**，对应于两种状态，返回值也是两个

每个节点的返回值，**0代表偷该节点，1代表不偷该节点**

二叉树的遍历，因为需要用到左右节点的数值，因此，需要**采用后序遍历**

递推公式：

如果选择偷，那么左右必不能偷，left[1] + right[1] + cur->val

如果选择不偷，那么左右偷或者不偷都可以，然后计算两边最大的，然后相加 max(left[0], left[1]) + max(right[0], right[1])

```C++
class Solution {
public:
    int rob(TreeNode* root) {
        if(root == NULL)    return 0;
        vector<int> res = robArgs(root);
        return max(res[0], res[1]);
    }
private:
    //每个节点的返回值，0代表偷该节点，1代表不偷该节点
    vector<int> robArgs(TreeNode* cur){
        //终止条件，空节点返回 0，0
        if(cur == NULL)
            return {0,0};
        
        //分别获得左右孩子的返回值
        vector<int> left = robArgs(cur->left);
        vector<int> right = robArgs(cur->right);
        //求该节点能获得的最大值
        //0, 偷
        int first = left[1] + right[1] + cur->val;
        //1，不偷
        int second = max(left[0], left[1]) + max(right[0], right[1]);

        return vector<int> {first, second};
    }
};
```





## 背包问题

## 0-1背包

一维DP：

> 一维 dp 是对二维的压缩，本质上用的就是二维的

背包的遍历顺序：

> **背包从后向前遍历**，这样才能保证用的是上一层未更新的状态，保证每个物品只使用一次

for循环的嵌套顺序：

>**先遍历物品，再遍历背包，**原因是背包是倒序遍历，如果先遍历背包，就不能使用上一层的值了，这样每次只能取一个物品

## 完全背包

背包的遍历顺序：

> 因为是每个物品可以无限的取，那么**背包从前向后遍历**，这样使用的是上一层更新后的状态

for循环的嵌套顺序：

> 背包是从前向后的，那么就**先遍历背包还是物品都行**，因为都可以使用上一层的值
>
> 如果先遍历物品，那么物品的先后顺序就是确定的了，解决 顺序不影响 的问题
>
> 如果先遍历背包，那么物品的先后顺序不确定，解决 顺序影响 的问题



### [698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)

思路：



```C++
```





### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

思路：

变换成背包问题，体积为 sum/2 的背包，能够装的最大价值，其中每个物体就是 nums 里面的数，体积 w 是自身，价值 v 也是自身

如果最后背包能够装满，说明可以找到，否则，就找不到

- dp[j] 表示体积为 j 的背包能够装的物品的最大价值

初始化，首先dp [0] 一定是0。如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷

使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！

递推公式：dp [j] = max( dp [j], dp [j - nums [i] ] + nums [i] )

```C++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        //首先定义一些东西，背包的体积 bagWeight 是和的一半
        //每个物体就是 nums 里面的数，体积 w 是自身，价值 v 也是自身
        int sum = 0;
        for(int i = 0; i < nums.size(); ++i){
            sum += nums[i];
        }
        //如果是奇数，直接返回false
        if(sum % 2 != 0)    return false;

        int W = sum /2;
        // dp[j] 表示体积为 j 的背包能够装的物品的最大价值
        vector<int> dp(W+1, 0);

        //初始化就是 0
        //for循环，先遍历物品
        for(int i = 0; i < nums.size(); ++i){
            //从后向前遍历，保证每个物品只拿一次
            for(int j = W; j >= nums[i]; --j){
                //递推公式就是，不取这个物品，和取这个物品
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        //如果背包能够装满，说明可以找到等和的子集
        if(dp[W] == W)
            return true;
        else
            return false; 
    }
};
```

### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)

思路：

相当于找到两组石头，它们的重量最接近，那么抽象成 用总和一半容积的背包去装，能够装的最大的重量，这样两组的重量最接近

-  dp[i] 表示背包容积为 i ，能够装最大的石头价值 dp[i]

初始化，首先dp [0] 一定是0。如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷

使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！

递推公式：dp [j] = max( dp[ j ], dp [ j - stones [ i ] ] + stones [ i ])

```C++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        //定义背包的体积 target 等于石头重量的一半
        //物品的个数就是石头的数量，体积 weight 和 value 就是数值
        int sum = 0;
        for(int i = 0; i < stones.size(); ++i)  
            sum += stones[i];
        // dp[i] 表示背包容积为 i ，能够装最大的石头价值 dp[i]
        int target = sum / 2;
        vector<int> dp(target + 1, 0);

        //初始化为 0
        //for 循环，外层物品，内层背包容积，从后向前防止重复取
        for(int i = 0; i < stones.size(); ++i){
            for(int j = target; j >= stones[i]; --j)
                dp[j] = max(dp[j], dp[j-stones[i]] + stones[i]);
        }
        return sum - dp[target] * 2;
    }
};
```

### [494. 目标和](https://leetcode.cn/problems/target-sum/)

思路：

寻找关系式，分成两组，一组是正数的和，一组是负数的和，那么

就存在left - right = target，而 left + right = sum，那么 left = (sum + target) / 2。寻找正数和是 left 的组合数量

其中 （sum+ target）一定是偶数，如果不是，说明无法满足。

同时如果 target 的绝对值比 sum 还要大，说明即使全部是正号也不行

- dp [i] 表示和为 i 的不同的数量

递推公式就是，如果新增了一个物品，不拿这个数，就是 dp[j] 种方法，拿了这个数，就是 dp [j - nums[i]] 种方法，两者之和即为：

**dp[j] += dp[j - nums[i]]**

这里的**初始化比较有意思**，肯定是不能初始成 0 的，如果是 0 ，那么后续的所有和都是 0 了，所以这里初始化为 1，实际意义是装满容量为0的背包，有1种方法，就是装0件物品，（感觉有点牵强）

```C++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        //定义 背包的容积 就是 所有正数和 sum+
        //物品 就是每个数，体积 weight 和价值 value 都是自身的数值
        int sum = 0;
        for(int i = 0; i < nums.size(); ++i)
            sum += nums[i];
        int sum_plus = (sum + target)/2;
        if((sum + target) % 2 != 0)   return 0;
        //如果 target 的绝对值比 总和还大，也不行
        if(abs(target) > sum)   return 0;
        //dp [i] 表示和为 i 的不同的数量
        vector<int> dp(sum_plus + 1, 0);

        //初始化
        dp[0] = 1;

        //for循环，外层物品（数）循环，内层背包容积循环
        for(int i = 0; i <nums.size(); ++i){
            for(int j = sum_plus; j >= nums[i]; --j)
                dp[j] += dp[j - nums[i]] ;
        }
        return dp[sum_plus];
    }
};
```

### [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)

思路：

这里的背包是有两个的，分别是代表 0 的 m, 和代表 1 的 n。一开始是想分成两个背包计算，但是发现当选择某个数的时候，不能同时更新。因此，这里需要使用一个背包，但是定义两个维度

- dp[i] [j]表示以容量 i, j 的背包能够获得的最大子集数

递推公式，碰到一个数，选或者不选：**dp[j] [k] = max(dp[j] [k], dp[j-zero] [k-one] + 1)**

初始化， 因为没有负值，并且递推公式中有加一，所以初始化为 0

遍历顺序，先物品后背包，这里的背包的两个维度都要遍历，从后向前防止重复拿取

```C++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        //定义，两个背包，容积分别是 m, n
        //物品从 strs 里面取，重量和价值相等，都是 其数值
        // dp[i][j] 表示以容量 i, j 的背包能够获得的最大子集数
        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));
        //初始化都为 0
        //for循环从前开始遍历
        for(int i = 0; i < strs.size(); ++i){
            vector<int> num = zero_one(strs[i]);
            int zero = num[0], one = num[1];
            //分别遍历背包 j, k
            for(int j = m; j >= zero; --j){
                for(int k = n; k >= one; --k){
                    //选择或者不选择
                    dp[j][k] = max(dp[j][k], dp[j-zero][k-one] + 1);
                }
            }
        }
        return dp[m][n];
    }
private:
    vector<int> zero_one(const string& str){
        int zero = 0, one = 0;
        for(int i = 0; i < str.size(); ++i){
            if(str[i] == '0')
                zero++;
            else
                one++;
        }
        return vector<int>{zero, one};
    }
};
```

### [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-2/)

思路：

背包的容积就是需要凑成的面额 amount

- dp [i] 表示凑成面额为 i 的方法数有 dp[i] 种

递推公式，不选该面额的方法数，加上选该面额的方法数 dp[j] += dp[j-coins[i]]

因为递推公式中没有 加数字，因此，这里的 dp[0] 初始化为 1，同时也意味着凑成面额为 0 的方法有 1 种

因为是完全背包，先遍历物品，遍历背包的时候可以从前往后遍历，这样可以**重复选择**

```C++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        //定义，背包的容积就是需要凑成的面额 amount
        //物品是不同面额的硬币，重量和价值都是其数值
        //dp [i] 表示凑成面额为 i 的方法数有 dp[i] 种
        vector<int> dp(amount+1, 0);

        //dp[0] 初始化成1，不然递推公式无法进行
        dp[0] = 1;
        //先遍历物品，再遍历背包，可以重复取，背包从前向后遍历
        for(int i = 0; i < coins.size(); ++i){
            for(int j = coins[i]; j <= amount; ++j){
                dp[j] += dp[j-coins[i]];
            }
        }
        return dp[amount];
    }
};
```

### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

思路：

首先是可以重复取，是完全背包，其次是 顺序影响结果，所以应该先遍历背包再遍历物品

- dp [i] 表示和为 i 的组合个数是 dp[i]

递推公式：选或者不选，dp[j] += dp[j-nums[i]]

初始化 dp[0] 为1， 方便计算

遍历顺序看上面总结的 [完全背包](##完全背包)

```C++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        // 定义，背包的容积就是目标数 target
        //物品就是数，重量和价值都是 其自身数值
        // dp [i] 表示和为 i 的组合个数是 dp[i]
        vector<int> dp(target+1, 0);

        //初始化
        dp[0] = 1;
        //完全背包，循环向后遍历, 顺序影响结果， 先遍历背包，后遍历物品
        for(int j = 0; j <= target; ++j){
            for(int i = 0; i < nums.size(); ++i){
                //如果能够放进来,这里还要加个放置溢出的条件
                if(j >= nums[i] && dp[j] < INT_MAX - dp[j-nums[i]])
                    dp[j] += dp[j-nums[i]];
            }
        }
        return dp[target];
    }
};
```

### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

思路：

- dp [i] 表示凑成面额为 i 所需要的最少硬币数 dp[i]

递推公式，不选就是上层的最小值，选了就是 对应的最小值加一： dp[j] = min(dp[j], dp[j-coins[i]] + 1)

因为需要选择最小的，因此 dp[i] 初始化成 INT_MAX，但是 dp[0] 初始化为 1

完全背包，背包从后向前遍历，顺序无影响，先遍历物品，再遍历背包

```C++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        //定义，完全背包，背包容积是 amount 
        //硬币就是物品，体积和价值都是其自身的数值
        //dp [i] 表示凑成面额为 i 所需要的最少硬币数 dp[i]
        vector<int> dp(amount+1, INT_MAX);
        //初始化
        dp[0] = 0;
        //for循环，完全背包，背包从前向后，顺序无影响，先遍历物品，再遍历背包
        for(int i = 0; i < coins.size(); ++i){
            for(int j = coins[i]; j <= amount && dp[j-coins[i]] != INT_MAX; ++j){
                dp[j] = min(dp[j], dp[j-coins[i]] + 1);
            }
        }
        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};
```

### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

思路：

- dp[i] 表示凑成和为 i 需要的完全平方数的最少数量

递推公式：dp[j] = min(dp[j], dp[j-square] + 1)

初始化 dp[0] 为 0

完全背包，背包从前向后遍历，顺序无影响，先遍历物品，后遍历背包。实际上**对于求最大最小等问题，先遍历哪个都可以**

```C++
class Solution {
public:
    //定义，背包的容积是 n
    //平方数就是物品，
    int numSquares(int n) {
        // dp[i] 表示凑成和为 i 需要的完全平方数的最少数量
        vector<int> dp(n+1, INT_MAX);
        //初始化
        dp[0] = 0;
        //完全背包，背包从前向后遍历，顺序无影响，先遍历物品，后遍历背包
        for(int i = 0; i <= 100; ++i){
            int square = i*i;
            for(int j = square; j <= n && dp[j-square] != INT_MAX; ++j){
                dp[j] = min(dp[j], dp[j-square] + 1);
            }
        }
        return dp[n] == INT_MAX ? -1:dp[n];
    }
};
```

### [139. 单词拆分](https://leetcode.cn/problems/word-break/)

思路：

单词就是物品，这里直接遍历单词进行比较也行，截断从映射表中查找也行

- dp[i] 表示长度为 i 的字符串能否用单词拼成

递推公式：如果截断的单词存在，并且该单词前面一个长度是 true，那么这个长度的字符串也能拼成，也是 true

初始化，dp[0] 为 true

遍历的顺序，是完全背包，背包从前向后遍历，至于 for 循环的嵌套顺序，顺序不影响结果，都行

```C++
class Solution {
public:
    //定义，背包就是字符串，容积就是长度
    //物品是单词，
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> u_set(wordDict.begin(), wordDict.end());
        // dp[i] 表示长度为 i 的字符串能否用单词拼成
        vector<bool> dp(s.size(), false);
        //初始化 
        dp[0] = true;
        //for循环遍历，先背包，后物品
        for(int j = 0; j < s.size(); ++j){
            for(int i = 0; i < j; ++i){
                string substr = s.substr(i, j - i);
                if(u_set.find(substr) != u_set.end() && dp[i])
                    dp[j] = true;
            }
        }
        return dp[s.size()];
    }
};
```







## 股票问题

股票问题，就是给你股票每天的价格，给你交易的次数，让你找到能够获得的最大利润

这里主要就是分析每天有几种状态，然后分别设置、更新每个状态

注意的几点：

- 是如果是第一次交易，需要注意状态不是 dp[i-1] [1] - prices[i] ，而是 **-prices[i]**，因为定义是第一次持有，如果今天买入，那么其实之前的都是不算数的，相当于回收之前的投资
- 还有初始化的时候，如果是每次持有，那么 dp[0] [持有] 都是 -prices[0]



### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

思路：

对于股票问题，可以分为两种情况，当天持有股票或者不持有股票，**注意这里是持有，而不是是否买入卖出等**

- dp[i] [0] 表示这天持有股票身上的金钱
- dp[i] [1] 表示这天不持有股票身上的钱

递推公式：

- 对于 dp[i] [0] 持有股票
- 一个是前一天持有股票，今天继续持有，就是 dp[i-1] [0]
- 另外一种就是前一天不持有，今天刚买入。**注意**这里的误区，不是 dp[i-1] [1] - prices[i] ，而是 **-prices[i]**，因为**本题是只能买卖一次**，如果今天买入，那么其实之前的都是不算数的，相当于回收之前的投资



- 对于 dp[i] [1]不持有股票
- 一种是前一天不持有，今天继续不持有 dp[i-1] [1]
- 第二种就是前一天持有，今天卖出 dp[i-1] [0] + prices[i]

初始化，第一天持有就是 -prices[0]，而不持有就是 0

for 循环进行遍历

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // dp[i][0] 表示这天 持有股票 手中的钱
        // dp[i][1] 表示这天 不持有股票 手中的钱
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        //初始化为
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        //循环遍历，
        for(int i = 1; i < prices.size(); ++i){
            //这天持有股票就是 前一天不持有，今天刚买，或者 前一天一直持有，今天不买
            //但是注意，本题只能买卖一次股票，如果今天买入，那么其实之前的都是不算数的，相当于回收之前的投资
            dp[i][0] = max(- prices[i], dp[i-1][0]);
            //这天不持有股票就是，前一天持有，今天卖了，或者昨天今天都不持有
            dp[i][1] = max(dp[i-1][0] + prices[i], dp[i-1][1]);
        }
        return dp[prices.size()-1][1];
    }
};
```

### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)

思路：

和上一题的差别就在这里是可以多次交易的，因此持有股票的推导有点区别，第一题已经讨论过

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // dp[i][0] 表示这天 持有股票 手中的钱
        // dp[i][1] 表示这天 不持有股票 手中的钱
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        //初始化为
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        //循环遍历，
        for(int i = 1; i < prices.size(); ++i){
            //这天持有股票就是 前一天不持有，今天刚买，或者 前一天一直持有，今天不买
            //这里因为可以多次交易，因此如果今天刚买，就是 dp[i-1][1] - prices[i]
            dp[i][0] = max(dp[i-1][1] - prices[i], dp[i-1][0]);
            //这天不持有股票就是，前一天持有，今天卖了，或者昨天今天都不持有
            dp[i][1] = max(dp[i-1][0] + prices[i], dp[i-1][1]);
        }
        return dp[prices.size()-1][1];
    }
};
```

### [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

思路;

对于股票问题，每一天都有很多状态，第一次持有，第一次不持有，第二次持有，第二次不持有等等，那么每天的每个状态都新增加一个维度

- dp[i] [0] 表示第一次持有股票 身上的现金
- dp[i] [1] 表示第一次不持有股票 身上的现金
- dp[i] [2] 表示第二次持有股票 身上的现金
- dp[i] [3] 表示第二次不持有股票 身上的现金

递推公式：

- dp[i] [0] 可以是前一天第一次不持有，以及前一天卖了，今天第一次买（注意归零，是 -prices[0] ）
- dp[i] [1] 可以是前一天第一次不持有，以及今天刚卖
- dp[i] [2] 可以是继承前一天的状态，以及前一天卖掉，今天刚买
- dp[i] [3] 可以是继承前一天的状态，以及今天刚卖掉

初始化：

- 这里初始化的时候，第二次持有为啥是 -prices[0]，
- 第二次买入依赖于第一次卖出的状态，其实相当于第0天第一次买入了，第一次卖出了，然后在买入一次（第二次买入），那么现在手头上没有现金，只要买入，现金就做相应的减少

```C++
/*
dp[i][0] 表示第一次持有股票 身上的现金
dp[i][1] 表示第一次不持有股票 身上的现金
dp[i][2] 表示第二次持有股票 身上的现金
dp[i][3] 表示第二次不持有股票 身上的现金
*/
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        //定义 dp 数组
        vector<vector<int>> dp(prices.size(), vector<int>(4, 0));
        //初始化为
        //第一次持有 和 第二次持有
        dp[0][0] = -prices[0];
        dp[0][2] = -prices[0];
        //遍历数组
        for(int i = 1; i < prices.size(); ++i){
            //如果是第一次持有股票，那么就是前一天持有股票， 或者今天刚买
            dp[i][0] = max(dp[i-1][0], -prices[i]);
            //第一次不持有股票，前一次也不持有，或者前一次持有，今天卖掉
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
            //第二次持有股票，就是前一天第二次持有，或者前一天第一次不持有，今天刚买第二次
            dp[i][2] = max(dp[i-1][2], dp[i-1][1] - prices[i]);
            //第二次不持有股票，就是前一天第二次不持有，或者前一天第二次持有，今天卖掉
            dp[i][3] = max(dp[i-1][3], dp[i-1][2] + prices[i]);
        }
        return dp[prices.size()-1][3];
    }
};
```

### [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

思路：

类似于上题，只要循环设置并且更新状态就行

```C++
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        //如果传入的数组不能满足 一 次交易
        if(prices.size() ==0 || k == 0)   return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(2*k, 0));
        //初始化，只要是偶数，那么就是持有状态，等于 -prices[0]
        for(int i = 0; i < 2*k; ++i){
            if(i%2 == 0)
                dp[0][i] = -prices[0];
        }
        for(int i = 1; i < prices.size(); ++i){
            dp[i][0] = max(dp[i-1][0], -prices[i]);
            for(int j = 1; j < 2*k; ++j){
                if(j%2 != 0)
                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i]);
                else
                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] - prices[i]);
            }
        }
        return dp[prices.size()-1][2*k - 1];
    }
};
```

### [309. 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

思路;

至少有两个元素时候，才有可能赚钱

注意购入的时候，需要冷冻一天，前一天的前一天

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        if(len == 1)    return 0;
        // dp[i][j] 表示第 i 天的各种持有和不持有情况
        vector<vector<int>> dp(len, vector<int>(2));
        //初始化
        dp[0][0] = -prices[0];
        dp[1][0] = max(-prices[1], -prices[0]);
        dp[1][1] = max(dp[0][1], dp[0][0] + prices[1]);
        //循环遍历
        for(int i = 2; i < len; ++i){
            //持有股票的情况
            dp[i][0] = max(dp[i-1][0], dp[i-2][1] - prices[i]);
            //不持有股票的情况
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
};
```

### [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

思路：

加了一个费用，交易结束的时候减掉就行

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        // dp[i][0] 表示这天 持有股票 手中的钱
        // dp[i][1] 表示这天 不持有股票 手中的钱
        vector<vector<int>> dp(prices.size(), vector<int>(2, 0));
        //初始化为
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        //循环遍历，
        for(int i = 1; i < prices.size(); ++i){
            //这天持有股票就是 前一天不持有，今天刚买，或者 前一天一直持有，今天不买
            //这里因为可以多次交易，因此如果今天刚买，就是 dp[i-1][1] - prices[i]
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);
            //这天不持有股票就是，前一天持有，今天卖了，或者昨天今天都不持有
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i] - fee);
        }
        return dp[prices.size()-1][1];
    }
};
```



## 最长序列问题

这里分成几个方面进行分析

- 所求的子序列是否是连续的
- 一个序列还是两个序列

**1、一个序列 + 子序列连续**

- dp[i] 表示以 nums[i] 结尾的序列，其连续递增的子序列的长度，对于每个位置来说，因为是递增的，需要和前面一个状态比较，所以和前一个状态是有关系的
- 对于每个位置，只需要和其前面一个位置比较，看能否在加在前面的序列上，不能就重新计算子序列的长度
- 这里计算的是以 nums[i] 结尾的连续递增的子序列的长度，**需要一个变量保存**最长的

**2、一个序列 + 子序列不连续**

- dp[i] 表示以 nums[i] 结尾的递增子序列的长度，那么对于每个 i 位置来说，并不能用到前面的状态，因为所求的序列是不连续的，和前一个的状态没有明显关系
- 于是对于每个位置，再遍历其前面的所有节点，看其能够加到哪个 nums[j] 结尾的子序列上
- 这里计算的是以 nums[i] 结尾的递增的子序列的长度，但不一定是最后一个最大，可能会在过程中出现，所以**需要一个参数保存**

**3、两个序列 + 子序列连续**

- 两个序列需要使用二维数组，分别代表两个序列的维度
- dp[i] [j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长连续公共子序列长度为dp[i] [j]，这样定义的话，后面不需要额外的初始化
- 对于每个位置，如果两个数相等，加在前面的子序列上面，加不上去的话，就需要重新计算了，**需要一个参数保存**

**4、两个序列 + 子序列不连续**

- dp[i] [j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列长度为dp[i] [j]
- 对于每个位置，如果两个数相等，加在前面的序列上，加不上去的话，因为并**不是连续**的，所以可以等于两个序列分别去掉最后一个数的最大值
- 这里根据定义，就**不需要参数保存**了



### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

思路：

- **dp[i] 表示以 nums[i] 结尾的序列的递增子序列的长度（因为递增子序列的最后一个元素是 nums[i]，所以不一定是最长）**

递推公式：**如果 nums[i] 比之前最后一个元素还大，那么就可以加在这个序列上**， dp[i] = max(dp[i], dp[j]+1)。这里因为 j 是从前向后遍历，因此 dp[i] 是不断更新的

初始化：因为每个位置都可以当成递增序列，所以是 1

for 循环：外层循环从前向后遍历，计算以每个位置结尾的递增子序列的长度。内层循环从前向后遍历，看 nums[i] 可以放到哪个位置上

```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size() <= 1)    return nums.size();
        //dp[i] 表示到 i 位置时，以 nums[i] 结尾的递增子序列的长度
        vector<int> dp(nums.size(), 1);
        //初始化
        int res = 0;
        //循环遍历, i 遍历每个数组表示以 i 为结尾
        for(int i = 1; i < nums.size(); ++i){
            //从前遍历，找到最大的结尾的子序列
            for(int j = 0; j < i; ++j){
                //如果以当前位置 i 结尾的数，比之前的 j 位置大，至少可以加在 j 后面，然后选择最大的
                if(nums[i] > nums[j])
                    //这里选择最大的，只要是选择前面所有的最大的，dp[i] 会不断更新的
                    dp[i] = max(dp[i], dp[j]+1);
            }
            //保存路径中的最长值
            if(dp[i] > res)
                res = dp[i];
        }
        //注意，最后的不一定是最长的
        return res;
    }
};
```



### [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

思路：

和上题的区别在于递增的子序列需要是连续的

- dp[i] 表示以 nums[i] 结尾的序列，其连续递增的子序列的长度

递推公式：如果这个位置比前一个数大，说明是连续递增的，那么可以加在前面这个子序列上面，dp[i] = dp[i-1] + 1，这里没有和前面所有的子序列对比，**只需要和前面一个比就行**

初始化：因为每个位置都可以当成递增序列，所以是 1

循环：外层循环从前向后遍历，计算以 nums[i] 结尾的序列的递增子序列的长度，因为不要和前面所有的比较，所以不需要内层遍历

```C++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if(nums.size() <= 1)    return nums.size();
        //dp[i] 表示以 nums[i] 结尾的序列，其连续递增的子序列的长度
        vector<int> dp(nums.size(), 1);
        //初始化
        int res = 0;
        //循环遍历, 外层循环，计算以 nums[i] 结尾的序列的递增子序列的长度
        for(int i = 1; i < nums.size(); ++i){
            //如果这个比前面的大，就能组成递增的子序列
            if(nums[i] > nums[i-1])
                dp[i] = dp[i-1] + 1;
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

### [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

思路：

两个维度进行比较，比较以（i，j)  两个子序列组成的公共子序列的长度

- dp[i][j] 表示以 nums1[i]，nums2[j] 结尾的序列的 公共子序列的长度

递推公式，如果两个序列的结尾元素是一样的，那么看前面的结尾元素是否是一样的，dp[i] [j] = dp[i-1] [j-1] + 1

初始化：可能没有一样的，初始化为 0 就行

遍历顺序：两层 for 循环嵌套

```C++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        //dp[i][j] 表示以 nums1[i]，nums2[j] 结尾的序列的 公共子序列的长度
        vector<vector<int>> dp(nums1.size(), vector<int>(nums2.size(), 0));
        //初始化
        int res = 0;
        for(int i = 0; i < nums1.size(); ++i)
            if(nums1[i] == nums2[0]){
                dp[i][0] = 1;
                res = 1;
            }      
        for(int j = 0; j < nums2.size(); ++j)
            if(nums1[0] == nums2[j]){
                dp[0][j] = 1;
                res = 1;
            }           
        //循环遍历，外层循环遍历以 nums1[i] 结尾的序列
        for(int i = 1; i < nums1.size(); ++i){
            //内层循环遍历以 nums2[j] 结尾的序列
            for(int j = 1; j < nums2.size(); ++j){
                if(nums2[j] == nums1[i]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }
                res = max(res, dp[i][j]);
            }
        }
        return res;
    }
};
```

### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

思路：

两个维度比较

- 一种 dp 是，dp[i] [j] 表示 text1 以 text1[i] 结尾的子序列，和 text2 以 text2[j] 结尾的子序列的公共子序列长度
- 另一种是，dp[i] [j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列长度为dp[i] [j]

递推公式：如果两个数一样，那么就是 dp[i] [j] = dp[i-1] [j-1] + 1，否则就选上面和左边最大的 dp[i] [j] = max(dp[i] [j-1], dp[i-1] [j])

初始化：第二种 dp 的写法就不需要初始化了，因为让 text1[0] 与 text2[0] 对应成了 dp[1] （产生了偏移），这样就能同样的处理了

循环：用到了左边和上面的值，从前向后遍历即可

```C++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        // dp[i][j] 表示 text1 以 text1[i] 结尾的子序列，和 text2 以 text2[j] 结尾的子序列的公共子序列长度
        vector<vector<int>> dp(text1.size(), vector<int>(text2.size(), 0));
        //初始化,因为需要用到左上角的值，所以循环从 1 开始，需要初始化 dp[0][j] 与 dp[i][0]
        bool flag_i = false;
        bool flag_j = false;
        for(int i = 0; i < text1.size(); ++i){
            if(text1[i] == text2[0])
                flag_i = true;
            if(flag_i)
                dp[i][0] = 1;
        }  

        for(int j = 0; j < text2.size(); ++j){
            if(text2[j] == text1[0])
                flag_j = true;
            if(flag_j)
                dp[0][j] = 1;
        }
            
        //遍历
        for(int i = 1; i < text1.size(); ++i){
            for(int j = 1; j < text2.size(); ++j){
                //如果两个数相等，就是左上角的数加一
                if(text1[i] == text2[j])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return dp[text1.size()-1][text2.size()-1];
    }
};
/******************************** 		简洁化			*********************************************/
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        // dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]
        vector<vector<int>> dp(text1.size()+1, vector<int>(text2.size()+1));
        // 初始化, 因为之前就是0了，不需要手动了
        //遍历，每个数组
        for(int i = 1; i <= text1.size(); ++i){
            for(int j = 1; j <= text2.size(); ++j){
                //如果这次的 i，j 的元素是相同的, 那么
                if(text1[i-1] == text2[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else
                    dp[i][j] = max(dp[i][j-1], dp[i-1][j]);
            }
        
        return dp[text1.size()][text2.size()];
    }
};
```

### [1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/)

思路：

其实就是找两个序列的最长公共子序列的长度

```C++
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        //dp[i][j] 表示以 nums1[i-1] 和 nums2[j-1] 结尾的两个序列的最长公共子序列的长度
        vector<vector<int>> dp(nums1.size()+1, vector<int>(nums2.size()+1, 0));
        //初始化就是 0 ， 不需要额外操作了
        //遍历，两层循环
        for(int i = 1; i <= nums1.size(); ++i){
            for(int j = 1; j <= nums2.size(); ++j){
                //如果两个数相等，就是左上角的值加一
                if(nums1[i-1] == nums2[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return dp[nums1.size()][nums2.size()];
    }
};
```





## 编辑距离

给定两个字符串，判断变成相同的字符串所需要的步数

首先是定义：

- dp[i] [j] 表示word1[i-1] 与 word2[j-1] 变成相同字符串所需要的最小步数

递推公式：就两种情况，一种是当前的字符相等，一种是不相等

- **word1[i-1] == word2[j-1]** ，这样就等于 dp[i-1] [j-1]
- **word1[i-1] != word2[j-1]**，这时候，就看题目描述了
- 如果有增、删、改，那么其实增和删是相同的操作
- 增、删：删掉 word1的末尾元素，和删掉 word2的末尾元素，min(dp[i-1] [j], dp[i] [j-1]) + 1
- 改：改掉 word1 或者 word2 的末尾元素，是 dp[i-1] [j-1] + 1
- **dp[i] [j] = min({dp[i-1] [j], dp[i] [j-1], dp[i-1] [j-1]}) + 1**

初始化：从意义上看，dp[i] [0] 和 dp[0] [j] 就是删除那个字符串直到空，其实就是字符的个数

遍历顺序：从前向后即可

### [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

思路：

这是编辑距离的入门题，仅仅只需要考虑删除元素，本题转换成两个序列能够匹配的字符数量

- dp[i] [j] 表示以 s[i-1] 与 t[j-1] 结尾的子序列，能够匹配的数量

递推公式：如果该位置两个数相等，那么就是没有加该位置时匹配的数量，再加一，dp[i] [j] = dp[i-1] [j-1] + 1，不相等的话，就让看长的序列的前一个位置匹配的数量

初始化：根据定义，全部初始化为 0 即可

循环：先遍历短的序列，再遍历长的序列，从前向后，（当然先遍历长的也行）

```C++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        if(s.size() > t.size()) return false;
        //dp[i][j] 表示以 s[i-1] 与 t[j-1] 结尾的子序列，能够匹配的数量
        vector<vector<int>> dp(s.size()+1, vector<int>(t.size()+1, 0));
        //初始化
        //遍历
        for(int i = 1; i <= s.size(); ++i){
            for(int j = 1; j <= t.size(); ++j){
                //如果此时的两个位置相等，那么就是 各去掉一个 再加一
                if(s[i-1] == t[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                //否则 就是前一个匹配的个数
                else
                    dp[i][j] = dp[i][j-1];
            }
        }
        return dp[s.size()][t.size()] == s.size() ? true : false;
    }
};
```

### [115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)

思路：

这种问题基本的思路就是判断 s[i-1] 与 t[j-1] 之间是否相等，从而确定递推公式

- dp[i] [j] 表示 s[i-1] 中出现 t[j-1] 序列的个数

递推公式：如果此时的两个位置相等，那么可以选择是否用当前的 s[i-1] 进行匹配，如果用数量就是 dp[i-1] [j-1]，如果不用就是dp[i-1] [j]

初始化：这里是有实际意义的，dp[i] [0] 表示以 i 结尾的字符串出现 空字符串的数量，是 1，而 dp[0] [j] 是 空字符串中出现 j 结尾的字符串的个数

循环：从前向后遍历

```C++
class Solution {
public:
    int numDistinct(string s, string t) {
        //dp[i][j] 表示 s[i-1] 中出现 t[j-1] 序列的个数
        vector<vector<long long>> dp(s.size()+1, vector<long long>(t.size()+1, 0));
        //初始化，注意这里的 dp[i][0] 和 dp[0][j] 需要初始化
        //dp[i][0] 表示以 i 结尾的字符串出现 空字符串的数量
        for(int i = 0; i <= s.size(); ++i)  dp[i][0] = 1;

        //循环遍历
        for(int i = 1; i <= s.size(); ++i){
            for(int j = 1; j <= t.size(); ++j){
                //如果此位置的两个数相等了，那么就是可以用这个位置进行匹配
                if(s[i-1] == t[j-1])
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                else
                    dp[i][j] = dp[i-1][j];
            }
        }
        return dp[s.size()][t.size()];
    }
};
```

### [583. 两个字符串的删除操作](https://leetcode.cn/problems/delete-operation-for-two-strings/)

思路：

- dp[i] [j] 表示以 word1[i-1] 和 word2[j-1] 两个序列相同的最小步数

**递推公式：**如果当前位置两个字符是相等的，那么就等于各去掉一个的步数

当word1[i - 1] 与 word2[j - 1]不相同的时候，有三种情况：

情况一：删word1[i - 1]，最少操作次数为dp[i - 1] [j] + 1

情况二：删word2[j - 1]，最少操作次数为dp[i] [j - 1] + 1

情况三：同时删word1[i - 1]和word2[j - 1]，操作的最少次数为dp[i - 1] [j - 1] + 2

**初始化：**从意义上看，dp[i] [0] 和 dp[0] [j] 就是删除那个字符串直到空，其实就是字符的个数

**顺序：**就是从前向后

```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        //dp[i][j] 表示以 word1[i-1] 和 word2[j-1] 两个序列相同的最小步数
        vector<vector<int>> dp(word1.size()+1, vector<int>(word2.size()+1, INT_MAX));
        //初始化, dp[0][0] 表示两个空字符串，最小步数就是0
        //dp[i][0] 和 dp[0][j] 就是删除那个字符串直到空，其实就是字符的个数
        for(int i = 1; i <= word1.size(); ++i)  dp[i][0] = i;
        for(int j = 1; j <= word2.size(); ++j)  dp[0][j] = j; 
        dp[0][0] = 0;
        //for循环遍历
        for(int i = 1; i <= word1.size(); ++i){
            for(int j = 1; j <= word2.size(); ++j){
                //如果当前位置两个字符是相等的，那么就等于各去掉一个的步数
                //否则，就等于 word1 去掉一个和 word2 去掉一个的较小值
                if(word1[i-1] == word2[j-1]){
                    dp[i][j] = dp[i-1][j-1];
                }
                else
                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1;
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

思路：

- dp[i] [j] 表示word1[i-1] 与 dp[j-1] 变成相同字符串的最短距离

**递推公式**：同样是分成两种情况，当前位置的字符是否相等

**相等**：就是等于各去掉末尾字符，然后不操作

**不相等**：分成增，删，改，这里的增加和删除是相同的

**增、删**：删掉 word1的末尾元素，和删掉 word2的末尾元素，min(dp[i-1] [j], dp[i] [j-1]) + 1

**改：**改掉 word1 或者 word2 的末尾元素，是 dp[i-1] [j-1] + 1

- dp[i] [j] = min({dp[i-1] [j], dp[i] [j-1], dp[i-1] [j-1]}) + 1

**初始化：**从意义上看，dp[i] [0] 和 dp[0] [j] 就是删除那个字符串直到空，其实就是字符的个数

遍历顺序：从前向后

```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        //dp[i][j] 表示word1[i-1] 与 word2[j-1] 变成相同字符串的最短距离
        vector<vector<int>> dp(word1.size()+1, vector<int>(word2.size()+1, INT_MAX));
        //初始化
        for(int i = 1; i <= word1.size(); ++i)  dp[i][0] = i;
        for(int j = 1; j <= word2.size(); ++j)  dp[0][j] = j;
        dp[0][0] = 0;
        //循环遍历
        for(int i = 1; i <= word1.size(); ++i){
            for(int j = 1; j <= word2.size(); ++j){
                //如果此时的两个字符相等,那么就是各去掉末尾的步数
                if(word1[i-1] == word2[j-1])
                    dp[i][j] = dp[i-1][j-1];
                else
                    //如果不相等，那么增，删，改，增加的操作相当于删除的操作
                    //而换的话，就是换掉两个其中的一个，是 dp[i-1][j-1] + 1
                    dp[i][j] = min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}) + 1;
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```





## 其他

### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

思路：

- dp [i] 表示到达 i 层台阶的走法
- dp [0] 的没有实际意义，这里初始化为 1
- 遍历的顺序是从前到后
- 递推公式就是前面两个数相加

```C++
class Solution {
public:
    int climbStairs(int n) {
        //dp[i] 表示到达第 i 层台阶所有的方法
        vector<int> dp(n+1, 0);
        //dp数组的初始化
        dp[0] = 1;
        dp[1] = 1;
        
        //遍历顺序
        for(int i = 2; i < dp.size(); ++i){
            //递推公式
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```

### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

思路：

- dp [i] 这里定义的是到达第 i 层所需要的花费，这样会到达 n 这个位置。但是还有另外一种定义，定义为支付了 i 这层花费之后的最小花费，这样就到达 i -1 这个位置就行
- 初始化，第一种的话，前两个为 0 就好，前两个台阶不需要花费
- 遍历顺序就是从前到后
- 递推公式选择前面两个支付价格之后 花费较小的

```C++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        //dp[i] 表示到达 i 层台阶的最小花费
        int n = cost.size();
        vector<int> dp(n+1, 0);
        //初始化，dp[0] dp[1] 是0就行

        //从前向后遍历
        for(int i = 2; i < n+1; ++i){
            //递推公式，选择前面两个支付价格之后 花费较小的
            dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);
        }
        return dp[n];
    }
};
```

### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

思路：

- dp [i] [j] 表示达到 (i,j) 这个位置的路径数
- 初始化左边和上边，因为这里都只有一种走法
- 遍历顺序就用从左到右，从上到下
- 递推公式是 左边和上面的路径和

```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        //dp[i][j] 表示达到 (i,j) 这个位置的路径数
        vector<vector<int>> dp(m, vector<int>(n, 0));

        //最上方只有一种走法，就是向右走
        for(int j = 0; j < n; ++j)
            dp[0][j] = 1;
        //最左边也只有一种走法
        for(int i = 0; i < m; ++i)
            dp[i][0] = 1;

        //从第二行第二个开始遍历
        for(int i = 1; i < m; ++i){
            for(int j = 1; j < n; ++j){
                //递推公式
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```

### [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

思路：

类似上一题，只不过在循环更新 dp 数组的时候，需要判断，如果是障碍物就不可能达到，路径数为 0 就行，否则就是左边和上面的和

处理最上面和最左边的时候，注意碰到障碍物后，后面的就不可达了，也就是 0 。又因为初始化的是 0 ，所以只需要更新碰到障碍物前的位置是 1 就行了

```C++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        //dp[i][j] 表示达到 (i,j) 这个位置的路径数
        int m = obstacleGrid.size(); 
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));

        //最上方碰到障碍物时候，后面的全部变成0,因为初始化为0，只需要让前面不是 0 的为 1就行了
        for(int j = 0; j < n && obstacleGrid[0][j] == 0; ++j)
            dp[0][j] = 1;

        //最左边也是，没有碰到障碍物时候，改成 1 就行
        for(int i = 0; i < m && obstacleGrid[i][0] == 0; ++i)
            dp[i][0] = 1;

        //从第二行第二个开始遍历
        for(int i = 1; i < m; ++i){
            for(int j = 1; j < n; ++j){
                //如果碰到障碍物，就让当前的路径数是0
                if(obstacleGrid[i][j] == 1)
                    dp[i][j] = 0;
                else
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```

### [343. 整数拆分](https://leetcode.cn/problems/integer-break/)

思路：

- dp [i] 表示第 i 个数可以拆分之后获得的最大乘积

初始化的时候，因为 dp[0] 与 dp[1] 实际上是没有意义的，因此，如果要有意义，需要初始化 dp [2]，这里从 dp [1] 开始

递推公式怎么想，从 j = 1 开始，对 i 进行拆分，拆分成两个数 j * (i - j) 或者多个数相乘 j * dp [i-j]

这里不拆分 j 的原因是，当 j 小于 i 的一半的时候，拆分的是 i - j，但是当 j 超过一半时，计算的 dp [i-j] 相当于在拆分之前的 j

```C++
class Solution {
public:
    int integerBreak(int n) {
        // dp[i] 表示可以拆分成 k 个数乘积的最大值
        vector<int> dp(n+1,0);

        //初始化,dp[0]用不到
        dp[1] = 1;
        //for循环，从 2 开始
        for(int i = 2; i < n+1; ++i){
            // j 从1开始循环
            for(int j = 1; j < i; ++j){
                //这里比较的是 j * (i-j) 与 j * dp[i-j]
                dp[i] = max({dp[i], j * (i-j), j * dp[i-j]});
            }
            cout << dp[i] << " ";
        }
        return dp[n];        
    }
};
```

### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

思路：

- dp [i] 表示 i 个节点组成的搜索二叉树的数量

这里的 dp [0] 初始化为 1，是为了计算方便，实际上空节点也算二叉搜索树？？

循环就是从前向后，同时里面也有循环。

这里可以注意到，举个例子，以 4 个节点组成的二叉搜索树数量就是

以 1 为根节点的二叉搜索树数量、以 2 为根节点的二叉搜索树数量、以 3 为根节点的二叉搜索树数量、以 4 为根节点的二叉搜索树数量

二层循环遍历：dp[j-1] * dp[i-j]

```C++
class Solution {
public:
    int numTrees(int n) {
        // dp [i] 表示 i 个节点组成的搜索二叉树的数量
        vector<int> dp(n+1, 0);

        //初始化, 这里的 dp[0] 为了计算方便
        dp[0] = 1;
        dp[1] = 1;

        //for循环从前向后遍历
        for(int i = 2; i <= n; ++i){
            for(int j = 1; j <= i; ++j){
                // 以 j 为根节点的搜索树数量
                //是左边的以 j-1 个数值组成的二叉搜索树 和 右边的以 i-j 个数值组成的二叉搜索树的数量的乘积
                dp[i] += (dp[j-1] * dp[i-j]);
            }
        }
        return dp[n];
    }
};
```

### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

思路：

- dp[i] 表示以 nums[i] 结尾的连续子数组的和

递推公式：这题很巧妙的利用了，如果前面的负数，那么就肯定不加，选择自身，于是 dp[i] = max(nums[i], dp[i-1] + nums[i])

初始化：dp[0] 初始化为 nums[0] 就好

遍历顺序：从前向后即可

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        //dp[i] 表示以 nums[i] 结尾的连续子数组的和
        vector<int> dp(nums.size(), INT_MIN);
        //初始化
        dp[0] = nums[0];
        int res = nums[0];
        //循环遍历
        for(int i = 1; i < nums.size(); ++i){
            //判断这个位置的数，与这个位置加上前一个位置的和
            //如果前面的是负数，那肯定不加
            dp[i] = max(nums[i], dp[i-1] + nums[i]);            
            res = max(res, dp[i]);
        }
        return res;
    }
};
```

### [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

思路：

- dp[i] [j] 表示区间 [i, j] 的字符串是否是回文子串

递推公式：如果两个位置不相等，那必然不是回文字符串，如果相等，那么有三种情况：

- 情况1：‘a' 字符串只有一个，那么必然是回文
- 情况2：'aa' 这种只有两个字符的已必然是回文
- 情况3：’aba' 这种超过三个的字符了，需要向里面收缩，dp[i+1] [j-1] ，然后继续判断

初始化：都是false就行

遍历顺序：需要用到 dp[i+1] [j-1]，那么 i 需要从后向前遍历

```C++
class Solution {
public:
    int countSubstrings(string s) {
        //dp[i][j] 表示区间 [i, j] 的字符串是否是回文子串
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), false));
        //初始化
        int res = 0;
        //遍历
        //外层循环遍历所有的位置
        //外层循环，从后向前遍历
        for(int i = s.size() - 1; i >= 0; --i){
            //内层循环，从 i 的位置开始向后遍历
            for(int j = i; j < s.size(); ++j){
                //如果两个字符相等，需要判断其是不是回文的
                if(s[i] == s[j]){
                    //如果 i 与 j 相等，或者 i+1 == j-1，一定是 true
                    if(j - i <= 1){
                        res++;
                        dp[i][j] = true;
                    }//否则，就向里面收缩一步
                    else if(dp[i+1][j-1]){
                        res++;
                        dp[i][j] = true;
                    }      
                }
            }
        }
        return res;
    }
};
```

### [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

思路：

区别在于一个是不能删除，而一个是可以删除的

- dp[i] [j] 表示区间 [i, j] 内的最长子序列长度

递推公式：

- 如果两个数相等，那么就在 dp[i+1] [j-1] 的基础上加2，dp[i] [j] = dp[i+1] [j-1] + 2
- 否则，就说明只能加入一个，加左边或者右边的，选择较大的 dp[i] [j] = max(dp[i] [j-1], dp[i+1] [j])

初始化：因为在后续的计算中，并没有计算 i==j 的情况，所以需要手动初始化，一个字符的回文子序列长度就是1，dp[i] [i] = 1

遍历顺序：需要用到 dp[i+1] [j-1]，那么 i 需要从后向前遍历

```C++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        //dp[i][j] 表示区间 [i, j] 内的最长子序列长度
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
        //初始化，因为下面计算不到 i==j，一个字符的回文子序列长度就是1
        for (int i = 0; i < s.size(); i++) dp[i][i] = 1;
        //循环遍历
        for(int i = s.size()-1; i >= 0; --i){
            for(int j = i+1; j < s.size(); ++j){
                //如果两个数相等，那么就能在 dp[i+1][j-1] 的基础上加2
                //否则，就说明只能加入一个，加左边或者右边的，选择较大的
                if(s[i] == s[j])
                    dp[i][j] = dp[i+1][j-1] + 2;
                else
                    dp[i][j] = max(dp[i][j-1], dp[i+1][j]);
            }
        }
        return dp[0][s.size()-1];
    }
};
```

### [801. 使序列递增的最小交换次数](https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/)

思路：

对于每个位置，都存在交换或者不交换的情况，如果只使用一维的 dp 数组，不能满足情况，所以使用二维数组。又因为两个位置，所以 dp[i] [0]，dp[i] [1]

- dp[i] [0] 表示到 i 的位置，不交换是格递增的，所需要的最小交换次数
- dp[i] [1] 表示到 i 的位置，交换后是递增的，需要的交换次数

初始化，让其为无穷，dp[0] [0] 和 dp[0] [1] 是 0

从前向后遍历，如果满足对应位置递增，那么该位置换不换取决于前一个换不换，如果前面不换，该位置不换，如果前面换，该位置也要换

如果满足交叉位置递增（注意，也可能对应位置也是递增的），那么该位置不换，就取前面的换和当前值（对应位置递增）的最小值

如果该位置换，那么就是前面不换加一，或者是当前值（因为不能确定前面换了之后，是否满足递增）？？？

```C++
class Solution {
public:
    int minSwap(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size();
        //dp[i][0] 表示到 i 的位置，不交换是格递增的，所需要的最小交换次数
        //dp[i][1] 表示到 i 的位置，交换后是递增的，需要的交换次数
        vector<vector<int>> dp(n, vector<int>(2, INT_MAX));

        //初始化
        dp[0][0] = 0;
        dp[0][1] = 1;

        //循环遍历
        for(int i = 1; i < n; ++i){
            //如果当前的值刚好是递增的
            if(nums1[i] > nums1[i-1] && nums2[i] > nums2[i-1]){
                //那么要么都不交换，要么都交换
                dp[i][0] = dp[i-1][0];
                dp[i][1] = dp[i-1][1] + 1;
            }
            //如果满足交叉大于的话,说明可以进行交换
            if(nums1[i] > nums2[i-1] && nums2[i] > nums1[i-1]){
                /*这里的条件是这样判断的，因为前面已经判断完 对应的大小了
                如果在满足对应大小的情况下，还满足交叉递增，那么就是这边的处理
                如果当前位置不换，可以选择前面一个换或者不换，选择两个较小的
                如果当前位置换，那么就是前面的不换，这里换，或者前面的和当前的都换，也就是已经换结束的（dp[i][1]）
                */
                dp[i][0] = min(dp[i][0], dp[i-1][1]);
                dp[i][1] = min(dp[i][1], dp[i-1][0] + 1);
            }
        }
        return min(dp[n-1][0], dp[n-1][1]);
    }
};
```



# 单调栈

**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**

单调栈的本质是空间换时间，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是只需要遍历一次



### [739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)

思路：

维护一个从栈底到栈头是单调递减的栈，就相当于找一个数，比当前的栈头大，就出栈

这里栈中，保存的是每个元素的下标，这样方便后面计算坐标之间的距离

定义一个结果数组，存放比当前位置大的下一个位置，之间的距离

首先让第一个元素的下标入栈，然后从第二个元素开始进行判断

如果当前的元素，比栈顶的元素小，说明不是要找的数，同样入栈等待 比它大的数出现

否则就找到了，同时进行判断需要出栈几个，如果栈不空，并且该数比栈顶元素大，计算它们之间的距离，保存到res数组中，同时还要出栈

处理完之后，还需要把这个元素的下标入栈

- **单调栈从栈底到栈头的顺序，单调递减**
- **栈中保存的是什么？是下标**

```C++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        //维护一个从栈底到栈头是单调递减的栈，就相当于找一个数，比当前的栈头大，就出栈
        //这里栈中，保存的是每个元素的下标，这样方便后面计算坐标之间的距离
        stack<int> st;
        //定义一个结果数组，存放比当前位置大的下一个位置，之间的距离
        vector<int> res(temperatures.size(), 0);
        //首先让第一个元素的下标入栈
        st.push(0);
        //然后从第二个元素开始进行判断
        for(int i = 1; i < temperatures.size(); ++i){
            //如果当前的元素，比栈顶的元素小，说明不是要找的数，同样入栈等待 比它大的数出现
            if(temperatures[i] <= temperatures[st.top()])
                st.push(i);
            else{
                //否则就找到了，同时进行判断需要出栈几个，如果栈不空，并且该数比栈顶元素大
                while(!st.empty() && temperatures[i] > temperatures[st.top()]){
                    //计算它们之间的距离，保存到res数组中，同时还要出栈
                    res[st.top()] = i - st.top();
                    st.pop();
                }
                //处理完之后，还需要把这个元素的下标入栈
                st.push(i);
            }
        }
        return res;

    }
};
```

### [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

思路：

其实就是对 nums2 找下一个最大的元素，然后再根据 nums1 需要的找

首先定义一个 unordered_map 用来做映射，key 是一个元素，value 是比 key 大的下一个元素

然后用 nums1 去查询即可

```C++
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        //首先计算 nums2 的每个元素的 下一个最大元素
        unordered_map<int, int> res2 = nextGreaterNum(nums2);
        //查询nums1 的位置，直接得到结果
        vector<int> res(nums1.size(), -1);
        for(int i = 0; i < nums1.size(); ++i){
            //如果找到了
            auto iter = res2.find(nums1[i]);
            if(iter != res2.end())
                res[i] = iter->second;
        }
        return res;
    }
private:
    //定义一个方法，计算一个数组 的下一个最大元素
    unordered_map<int, int> nextGreaterNum(const vector<int>& nums){
        unordered_map<int, int> umap;
        stack<int> st;
        st.push(nums[0]);
        for(int i = 1; i < nums.size(); ++i){
            while(!st.empty() && nums[i] > st.top()){
                umap.insert({st.top(), nums[i]});
                st.pop();
            }
            st.push(nums[i]);
        }
        return umap;
    }
    
};
```

### [503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/)

思路：

重点在于数组是循环的，遍历完结尾后，还可以找到其前面的值

碰到这类题目，很容易想到遍历这个数组两遍，相当于把在结尾 拼接上这个数组本身

重点在于，遍历两遍的过程中，**需要对下标取余，映射到原来的范围**

```C++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        stack<int> st;
        st.push(0);
        vector<int> res(nums.size(), -1);

        int n = nums.size();
        //遍历循环两次，注意对下标取余，才能从头继续找
        for(int i = 0; i < 2*n; ++i){
            while(!st.empty() && nums[i%n] > nums[st.top()]){
                res[st.top()] = nums[i%n];
                st.pop();
            }
            st.push(i%n);
        }
        return res;
    }
};
```

### [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

思路：

最基本的想法是按列去接雨水，看每一列能够接到多少雨水，然后相加。对于每一列，需要找到左边最大的，右边最大的，然后选两者之间较小的，减去自身的高度，就是这一列能够接到的雨水的体积

**双指针**：遍历每一列，计算能够接雨水的体积。从当前列开始，向左向右遍历，维持两个数，分别是其左边最大的数和右边最大的数。

**动态规划：**动态的维护两个数组，分别代表每个位置下的，左边最大高度和右边最大高度，直接取就行

**单调栈：**以行为单位进行计算，构建一个栈，当右边的比自己小的时候，就进栈说明还未找到右边能够装雨水的高度

如果右边的比栈顶元素大，那么说明可以装雨水了，先把栈顶元素的下标保存下来，再**出栈**，然后计算现在的栈顶元素和当前遍历的值（一个当成左边的高度，一个当成右边的高度），计算接到雨水的高度：h = min(height[i], height[st.top()]) - height[mid]

再计算雨水的宽度：w = i - st.top() - 1（使用下标计算它们之间的距离，是因为如果栈顶元素出栈后，栈顶元素依旧没有当前元素高，那就可以继续接雨水）

```C++
/****************************************        动态规划			********************************/
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size() <= 2)  return 0;
        //定义两个数组，分别保存 每个位置左边的最大高度和右边的最大高度
        vector<int> maxLeft(height.size(), 0);
        vector<int> maxRight(height.size(), 0);

        //从左向右，找到左边最大的高度
        maxLeft[0] = height[0];
        for(int i = 1; i < height.size(); ++i){
            //当前的高度和前一个的左边最大高度 比较，选择较高的
            maxLeft[i] = max(height[i], maxLeft[i-1]);
        }

        //从有向左，找到右边最大的高度
        maxRight[height.size() - 1] = height[height.size() -1];
        for(int i = height.size()-2; i >= 0; --i){
            maxRight[i] = max(height[i], maxRight[i+1]);
        }

        int sum = 0;
        for(int i = 1; i < height.size()-1; ++i){
            int h = min(maxLeft[i], maxRight[i]) - height[i];
            sum += h;
        }
        return sum;        
    }
};
/****************************************		单调栈				*****************************/
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size() <= 2)  return 0;
        //维持一个从栈底到栈头单调递减的栈
        stack<int> st;
        st.push(0);
        int sum = 0;
        for(int i = 1; i < height.size(); ++i){
            //如果当前比栈头小，入栈
            if(height[i] < height[st.top()])
                st.push(i);
            //如果相等，先出栈，再进栈
            else if(height[i] == height[st.top()]){
                st.pop();
                st.push(i);
            }
            else{
                while(!st.empty() && height[i] > height[st.top()]){
                    int mid = st.top();
                    st.pop();
                    if(!st.empty()){
                        int h = min(height[st.top()], height[i]) - height[mid];
                        int w = i - st.top() - 1;
                        sum += h * w;
                    }
                }
                st.push(i);
            }
        }
        return sum;
    }
};
```



# 思考题

### [672. 灯泡开关 Ⅱ](https://leetcode.cn/problems/bulb-switcher-ii/)

思路：

因为操作顺序不影响结果，且开关1+开关2=开关3，开关1+开关3=开关2，开关2+开关3=开关1，相同两次操作等于没有操作

可以发现，当 **n 大于等于3**，操作次数**presses 大于等于 3** 的时候，必定存在重复的组合，而且存在两次相同的操作，那么就可以相互抵消

这里的 n 大于等于 3是确保 一定存在 8 种以上的状态

最终状态只有 8 种：

> 初始状态、开关1、开关2、开关3、开关4、开关1+开关4、开关2+开关4、开关3+开关4

注意这里的 n=3，presses=2，的时候是 7，因为**必须按两次**，不存在按两次是开关4 的情况

```C++
class Solution {
public:
    int flipLights(int n, int presses) {
        //如果一次都不能按，那么只有一种初始状态
        if(presses == 0)    return 1;

        //接下来就是 presses > 0 的操作
        //在不存在 8 中状态之前先进行分情况考虑
        if(n == 1)  return 2;
        else if(n == 2) return presses==1 ? 3:4;
        else {
            if(presses == 1)
                return 4;
            else if(presses == 2)
                return 7;
            else
                return 8;
        }
    }
};
```



# 图论

## BFS

### [417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

思路：

水从高处流向海洋，那么反向思考，水可以从海洋流向高处，因为高处的起点是不确定的，需要求的，而低处的海洋位置是确定的

首先定义两个 bool 的矩阵 **res1，res2**，它们分别表示是否能够流向太平洋和大西洋，最后再全部遍历，当两个都是 true 的时候，就是行的

然后再定义两个队列 **Q1，Q2** 用来辅助 BFS

**注意**：这里需要注意的是，当进入队列的时候，有可能之前已经放进去了，需要进行判断，否则会造成一直循环的问题

```C++
class Solution {
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        int m = heights.size();
        int n = heights[0].size();
        //能够流向左上方的矩阵
        vector<vector<bool>> res1(m,vector<bool>(n, false));
        //能够流向右下方的矩阵
        vector<vector<bool>> res2(m,vector<bool>(n, false));
        //定义两个队列，从源点开始进行 BFS 
        queue<pair<int, int>> Q1;
        queue<pair<int, int>> Q2;
        vector<vector<int>> res;

        for(int i = 0; i < m; ++i){
            res1[i][0] = true;
            Q1.push({i, 0});
            res2[i][n-1] = true;
            Q2.push({i, n-1});
        }
            
        for(int j = 0; j < n; ++j){
            res1[0][j] = true;
            Q1.push({0, j});
            res2[m-1][j] = true;
            Q2.push({m-1, j});
        }

        BFS(heights, res1, Q1);
        BFS(heights, res2, Q2);
        
        for(int i = 0; i < m; ++i){
            for(int j = 0; j < n; ++j){
                if(res1[i][j] && res2[i][j])
                    res.push_back({i, j});
            }
        }
        return res;
    }
private:
    void BFS(vector<vector<int>>& heights, vector<vector<bool>>& vec, queue<pair<int, int>>& Q){
        int m = heights.size();
        int n = heights[0].size();
        //定义四个方向
        int dx[4] = {0, 1, 0, -1};
        int dy[4] = {1, 0, -1, 0};
        //如果队列不空，就一直让其寻找
        while(!Q.empty()){
            //取出这个数，
            pair<int, int> info = Q.front();
            Q.pop();
            int x = info.first;
            int y = info.second;
            //然后向四个方向移动
            for(int i = 0; i < 4; ++i){
                int nx = x + dx[i];
                int ny = y + dy[i];
                //判断是否出界
                if(nx < 0 || nx >= m || ny < 0 || ny >= n)
                    continue;
                //判断是否满足条件,如果不满足条件
                if(heights[x][y] > heights[nx][ny] || vec[x][y] == false)
                    continue;
                //如果之前加入过了，就是true，直接跳过,防止一直加入，无法跳出循环
                if(vec[nx][ny] == true)
                    continue;
                //说明满足条件
                Q.push({nx, ny});
                vec[nx][ny] = true;
            }
        }
        return;
    }
};
```

### [433. 最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/)

思路：

为何用 BFS ？

对于每一个基因序列，从头开始进行突变，让**每个位置都进行四次突变**（和原来一样的字符就不需要突变了）

这样就能得到突变一次后，能获得的所有基因序列，留下在 bank 中存在的基因序列

同时把这些有效的突变加入到队列中，进行下次突变，同时把这些基因序列存放到 map 中，key 是 基因序列， value 是突变的次数（**这些有效的突变都是1**）

每次清空队列，其实才相当于每个只做了一次突变

找到突变到 end 的最小突变次数

**这里发现，不需要 map 保存也行，因为会突变所有的位置，而且突变次数是从 1 开始往后加的，直接就是 step就行，也就是说第 step 轮循环，会找到 end，之前不可能找得到**

```C++
class Solution {
public:
    int minMutation(string start, string end, vector<string>& bank) {
        // 用 set 来保存基因库，方便查找
        unordered_set<string> u_set(bank.begin(), bank.end());
        //如果两个字符串相等，就是返回 0
        if(start == end)    return 0;
        //如果 end 是无效的，直接返回 -1
        if(!u_set.count(end))   return -1;

        //创建四个字符串
        char items[4] = {'A', 'C', 'G', 'T'};
        //创建一个队列，方便寻找
        queue<string> Q;
        //记录突变之后的字符串以及相应的次数
        unordered_map<string, int> u_map;       
        int step = 0;
        //获得所有，start基因突变的字符串，并记录在 map 中，以及次数
        Q.push(start);
        while(!Q.empty()){
            //每次取出里面的所有元素
            int size = Q.size();
            //每次取都算是同一批的，次数都是上次的加一
            step += 1;
            while(size-- > 0){
                //获得第一个头元素
                string cur = Q.front();
                Q.pop(); 
                //然后开始突变
                for(int i = 0; i < 8; ++i){
                    for(char c : items){
                        // 复制一下
                        string clone = cur;
                        //当变成的值，和自身一样的时候，就不变
                        if(c == clone[i])   continue;
                        //突变
                        clone[i] = c;
                        
                        //然后查询是否在 set 容器中
                        if(u_set.count(clone)){
                            //不管 start 和 end 是否相等，都插入到 u_map 中
                            u_map.insert({clone, step});
                            Q.push(clone);
                            //看是否和 end 相等
                            if(clone == end)    return u_map[end];                             
                        }
                        else
                            continue;
                    }
                }
            }
        }
        return -1;
    }
};
```

### [127. 单词接龙](https://leetcode.cn/problems/word-ladder/)

思路：

整体的 BFS 思路就是，让当前单词的每个位置都进行 25 种变化（除掉自己），然后在单词表中的留下来，可以继续进行后续的变化

同时插入到哈希表中， key 是单词， value 是到达这个单词需要变化的次数，这样能够防止重复变化

然后判断，和目标单词相同的返回，否则都插入到队列中，进行下次变化如果

但是本题这样做会超时，因为每个单词的每个位置都进行 25 种变化，搜索空间太大了

**双向BFS：**

只从开始向结尾搜索太慢，能不能也从结尾向开始搜索，然后找到某个中间单词，再把两个变化的次数相加

于是就需要定义两个队列，两个哈希表，分别从前向后和从后向前搜索，最后两边的次数相加

当两个队列都不空的时候，不停的处理，为了负载均衡，先搜索更短的那边

```C++
/*整体思路：就是每次只能变一个，让一个单词的所有位置进行 25 种变化，然后这 25 种继续变化*/
class Solution {
public:
    const char items[26] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
    unordered_set<string> u_set;
    string beginworld, endworld;

    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        //初始化一些东西
        for(string& str : wordList)
            u_set.insert(str);
        beginworld = beginWord;
        endworld = endWord;
        //如果 endWord 不在词典中，那必然是 0
        if(!u_set.count(endworld))  return 0;
        int res = bfs();
        //因为返回的是序列的长度，是变化的次数 + 1
        return res + 1;
        
    }
private:
    int bfs(){
        //创建两个队列，两个哈希表,并初始化
        queue<string> Q1;
        queue<string> Q2;
        unordered_map<string, int> M1;
        unordered_map<string, int> M2;
        Q1.push(beginworld);
        Q2.push(endworld);
        M1.insert({beginworld, 0});
        M2.insert({endworld, 0});

        //当两个队列都不空的时候，不停的处理,这里相当于每次对队列里面的单词进行处理
        while(!Q1.empty() && !Q2.empty()){
            int t = -1;
            //为了负载均衡，先搜索更短的那边
            if(Q1.size() <= Q2.size())
                t = update(Q1, M1, M2);
            else
                t = update(Q2, M2, M1);
            
            //如果 t 不是 -1， 说明 update找到了最小路径，否则就继续循环更新找
            if(t != -1)
                return t;
        }
        return -1;
    }

    int update(queue<string>& Q, unordered_map<string, int>& self, unordered_map<string, int>& other){
        //这里是清空队列的操作，对每个单词都进行变化
        int size = Q.size();
        while(size-- > 0){
            string cur = Q.front();
            Q.pop();
            for(int i = 0; i < cur.size(); ++i){
                for(char c : items){
                    string clone = cur;
                    //如果和自身的字母相等就不用变化了
                    if(c == clone[i])   continue;
                    //把该位置进行变化
                    clone[i] = c;
                    //不在单词表中，直接返回
                    if(!u_set.count(clone)) continue;

                    //如果自身之前搜索过，直接返回
                    if(self.count(clone))  continue;
                    //如果对方搜索到了，那么就说明能够对接
                    if(other.count(clone)){
                        //返回的是 变化到 cur 的次数加上这次变化的 1，再加上对方变到 clone 的次数
                        return self[cur] + 1 + other[clone];
                    }
                    else{
                        Q.push(clone);
                        //返回当前的值
                        self.insert({clone, self[cur] + 1});
                    }
                }
            }
        }
        return -1;
    }
};
```



## 并查集

### [827. 最大人工岛](https://leetcode.cn/problems/making-a-large-island/)

思路：

首先是定义一个并查集，再定义三个函数 `init`, `find`, `unite`

本题的主要想法是，对于一个为 1 的位置，让其四周为 1 的岛屿都合并到这个位置的集合下面，并且保存面积，这样遍历完之后，就能得到若干个整块的岛屿

然后遍历为 0 的位置， 如果把当前位置变成 1， 那么看其四周是否有**整块**的岛屿（如果四周有 1，那必定加入到了某块岛屿集合中 ），如果有，就加上这整块岛屿的面积，注意**不要重复**

```C++
class Solution {
public:
    const static inline vector<int> dirs = {-1, 0, 1, 0, -1};

    int largestIsland(vector<vector<int>>& grid) {
        int n = grid.size();
        //首先初始化 p 和 size
        init_p(n*n);
        init_s(n*n);

        int res = 1;
        for(int i = 0; i < n; ++i){
            for(int j = 0; j < n; ++j){
                //如果该位置是1
                if(grid[i][j]){
                    //遍历周围的四个节点，让其加入到当前位置的集合中
                    for(int k = 0; k < 4; ++k){
                        int x = i + dirs[k], y = j + dirs[k+1];
                        //如果出界，或者四周的是 0，就下一个
                        if(x < 0 || x >= n || y < 0 || y >= n)  continue;
                        if(!grid[x][y]) continue;
                        //否则就把周围的值，加到该位置的集合中
                        unite(x*n + y, i*n + j);
                        res = max(res, size[find(i*n+j)]);
                    }
                }
            }
        }

        //对于每个为 0 的点，其查找其四周为 1 的点，然后合并
        for(int i = 0; i < n; ++i){
            for(int j = 0; j < n; ++j){
                if(!grid[i][j]){
                    //这个表示该位置变成 1 能够获得的最大面积
                    int t = 1;
                    //这个表示已经合并了的 1
                    unordered_set<int> u_set;
                    //遍历四周，找到为 1 的，可以合并的点
                    for(int k = 0; k < 4; ++k){
                        int x = i + dirs[k], y = j + dirs[k+1];
                        //如果出界，或者四周的是 0，就下一个
                        if(x < 0 || x >= n || y < 0 || y >= n)  continue;
                        if(!grid[x][y]) continue;
                        //否则就说明找到了 1，接下来判断是否合并过，然后合并
                        int root = find(x*n + y);
                        if(!u_set.count(root)){
                            u_set.insert(root);
                            t += size[root];
                        }
                    }
                    //每个 0 找完之后，都更新最大值
                    res = max(res, t);
                    
                } 
            }
        }
        return res;
    }
private:
    void init_p(int n){
        p.resize(n);
        for(int i = 0; i < n; ++i)
            p[i] = i;
        return;
    }

    void init_s(int n){
        size.resize(n);
        for(int i = 0; i < n; ++i)
            size[i] = 1;
        return;
    }

    //查找操作
    int find(int x){
        if(p[x] != x)
            p[x] = find(p[x]);
        return p[x];
    }

    void unite(int a, int b){
        int pa = find(a);
        int pb = find(b);
        if(pa == pb)    return;
        p[pa] = pb;
        //把 pa 所有的集合，加到 pb 下面
        size[pb] += size[pa];

    }
    //这里是并查集的
    vector<int> p;
    vector<int> size;
};
```

## 拓扑排序

思路:

拓扑排序：需要构建一个入度数组，以及邻接矩阵（或者是 map，保存前置课程的后续课程），和一个辅助队列

首先遍历所有的依赖关系，得到每一门课的入度，以及前置课程的所有后续课程

让入度是 0 的课程入队列，然后出队，并且让其后续课程的入度减一，最后判断出队的数量

```C++
/*整体思路就是，构建入度数组，以及邻接矩阵和辅助队列*/
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        int n = prerequisites.size();
        if(n == 0)  return true;
        //构建入度数组
        vector<int> indegree(numCourses, 0);
        //构建邻接矩阵，前置课程保存其所有的后续课程
        vector<vector<int>> G(numCourses);
        //创建辅助队列
        queue<int> Q;
        int res = 0;

        //首先遍历依赖关系，初始化入度数组和邻接矩阵
        for(int i = 0; i < n; ++i){
            int a = prerequisites[i][0];
            int b = prerequisites[i][1];
            //入度处理
            indegree[a]++;
            //邻接矩阵处理
            G[b].push_back(a);
        }
        //然后对入度为 0 的节点，放入到辅助队列中
        for(int i = 0; i < numCourses; ++i){
            //如果是空的，就加入到队列中
            if(indegree[i] == 0)
                Q.push(i);
        }
        //当队列不是空的时候
        while(!Q.empty()){
            //首先获得size
            int size = Q.size();
            while(size-- > 0){
                //一个一个出队
                int cur = Q.front();
                Q.pop();
                res++;
                //然后把当前以 cur 为前置节点的 节点的入度减一
                for(int j = 0; j < G[cur].size(); ++j){
                    int a = G[cur][j];
                    indegree[a]--;
                    //如果入度是 0 了，就可以加入到队列中了
                    if(indegree[a] == 0)
                        Q.push(a);
                }
            }
        }
        return res >= numCourses ? true:false;
    }
};
```

